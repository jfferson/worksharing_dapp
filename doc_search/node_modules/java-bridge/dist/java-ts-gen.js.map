{"version":3,"file":"java-ts-gen.js","mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAc,KAAID,IAElBD,EAAW,KAAIC,GAChB,CATD,CASGK,QAAQ,IACX,M,kDCTA,IACEC,QAAQC,OAAOL,EAAQM,UAAY,UAAsB,IAA0B,0BAGrF,CAFE,MAAOC,GACP,MAAM,IAAIC,MAAM,iBAAmBD,EACrC,C,gBCLA,MAAM,WAAEE,EAAU,aAAEC,GAAiB,EAAQ,MACvC,KAAEC,GAAS,EAAQ,KAEnB,SAAEC,EAAQ,KAAEC,GAAST,QAE3B,IAAIU,EAAgB,KAChBC,GAAmB,EACnBC,EAAY,KAEhB,SAASC,IAEP,GAAKb,QAAQc,QAA8C,mBAA7Bd,QAAQc,OAAOC,UAOtC,CACL,MAAM,oBAAEC,GAAwBhB,QAAQc,OAAOC,YAAYE,OAC3D,OAAQD,CACV,CATE,IACE,MAAME,EAAU,eAAkC,aAAaC,WAAWC,OAC1E,OAAOd,EAAaY,EAAS,QAAQG,SAAS,OAGhD,CAFE,MAAOC,GACP,OAAO,CACT,CAKJ,CAEA,OAAQd,GACN,IAAK,UACH,OAAQC,GACN,IAAK,QACHE,EAAmBN,EAAWE,EAAKL,UAAW,4BAC9C,IAEIQ,EADEC,EACc,EAAQ,2HAER,QAAwB,4BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,IAAK,MACHX,EAAmBN,EAAWE,EAAKL,UAAW,+BAC9C,IAEIQ,EADEC,EACc,EAAQ,8HAER,QAAwB,+BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,QACE,MAAM,IAAIlB,MAAM,uCAAuCK,KAE3D,MACF,IAAK,QACH,OAAQA,GACN,IAAK,MACHE,EAAmBN,EACjBE,EAAKL,UAAW,6BAElB,IAEIQ,EADEC,EACc,EAAQ,4HAER,QAAwB,6BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,IAAK,OACHX,EAAmBN,EACjBE,EAAKL,UAAW,8BAElB,IAEIQ,EADEC,EACc,EAAQ,6HAER,QAAwB,8BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,IAAK,QACHX,EAAmBN,EACjBE,EAAKL,UAAW,+BAElB,IAEIQ,EADEC,EACc,EAAQ,8HAER,QAAwB,+BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,QACE,MAAM,IAAIlB,MAAM,wCAAwCK,KAE5D,MACF,IAAK,SACHE,EAAmBN,EAAWE,EAAKL,UAAW,+BAC9C,IAEIQ,EADEC,EACc,EAAQ,8HAER,QAAwB,gCAE1C,KACO,CAAP,MAAO,CACT,OAAQF,GACN,IAAK,MACHE,EAAmBN,EAAWE,EAAKL,UAAW,yBAC9C,IAEIQ,EADEC,EACc,EAAQ,wHAER,QAAwB,yBAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,IAAK,QACHX,EAAmBN,EACjBE,EAAKL,UAAW,2BAElB,IAEIQ,EADEC,EACc,EAAQ,0HAER,QAAwB,2BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,QACE,MAAM,IAAIlB,MAAM,sCAAsCK,KAE1D,MACF,IAAK,UACH,GAAa,QAATA,EACF,MAAM,IAAIL,MAAM,wCAAwCK,KAE1DE,EAAmBN,EAAWE,EAAKL,UAAW,0BAC9C,IAEIQ,EADEC,EACc,EAAQ,yHAER,QAAwB,0BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,IAAK,QACH,OAAQb,GACN,IAAK,MACH,GAAII,IAAU,CACZF,EAAmBN,EACjBE,EAAKL,UAAW,6BAElB,IAEIQ,EADEC,EACc,EAAQ,4HAER,QAAwB,6BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACF,KAAO,CACLX,EAAmBN,EACjBE,EAAKL,UAAW,4BAElB,IAEIQ,EADEC,EACc,EAAQ,KAER,QAAwB,4BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACF,CACA,MACF,IAAK,QACH,GAAIT,IAAU,CACZF,EAAmBN,EACjBE,EAAKL,UAAW,+BAElB,IAEIQ,EADEC,EACc,EAAQ,8HAER,QAAwB,+BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACF,KAAO,CACLX,EAAmBN,EACjBE,EAAKL,UAAW,8BAElB,IAEIQ,EADEC,EACc,EAAQ,6HAER,QAAwB,8BAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACF,CACA,MACF,IAAK,MACHX,EAAmBN,EACjBE,EAAKL,UAAW,kCAElB,IAEIQ,EADEC,EACc,EAAQ,iIAER,QAAwB,kCAI5C,CAFE,MAAOW,GACPV,EAAYU,CACd,CACA,MACF,QACE,MAAM,IAAIlB,MAAM,sCAAsCK,KAE1D,MACF,QACE,MAAM,IAAIL,MAAM,mBAAmBI,oBAA2BC,KAGlE,IAAKC,EAAe,CAClB,GAAIE,EACF,MAAMA,EAER,MAAM,IAAIR,MAAM,gCAClB,CAEA,MAAM,KAAEmB,EAAI,mBAAEC,EAAkB,eAAEC,EAAc,eAAEC,GAAmBhB,EAErEd,EAAOD,QAAQ4B,KAAOA,EACtB3B,EAAOD,QAAQ6B,mBAAqBA,EACpC5B,EAAOD,QAAQ8B,eAAiBA,EAChC7B,EAAOD,QAAQ+B,eAAiBA,C,mNC7PhC,kBAiCA,wDACqB,KAAAC,aAAoC,GACpC,KAAAC,gBAA4B,EA8CjD,CApCWC,eACHC,EACAC,EAA4C,MAE5C,IAAIC,EAAc,EAClB,IAAK,MAAMC,KAAaH,EAAY,CAChC,MAAMI,EAAY,IAAI,UAClBD,EACAF,EACAI,KAAKP,iBAEHQ,QAAkBF,EAAUG,WAClCL,GAAeI,EAAUE,OAEzBH,KAAKR,aAAaY,QAAQH,E,CAG9B,OAAOJ,CACX,CAQOH,WAAWW,SACR,UAA8BC,KAAKN,KAAKR,aAAca,EAChE,CAKWE,yBACP,OAAOP,KAAKR,YAChB,E,4yBChFJ,gBACA,SACA,YACA,WAEMgB,EAAa,UAAGC,iBAClB,YACA,GACA,UAAGC,aAAaC,QAChB,EACA,UAAGC,WAAWC,IAsEZC,EAAiC,CACnC,WACA,OACA,WACA,WACA,SACA,YACA,UAmBJ,MAAqBC,EAcjB,YACqBjB,EACAF,EAA4C,KAC5CH,EAA4B,IAF5B,KAAAK,UAAAA,EACA,KAAAF,iBAAAA,EACA,KAAAH,gBAAAA,EAhBb,KAAAuB,qBAA+B,EACtB,KAAAC,kBAA8B,GAC9B,KAAAC,iBAA6B,EAe3C,CAEKC,4BACJC,GAEA,MAAMC,QAAiB,IAAAC,kBACnB,8BAGEC,EAA8C,CAAC,EACrD,IAAK,MAAMC,KAAUJ,EAAS,CAC1B,MAAMK,QAAkBD,EAAOE,eAC/B,SAAUL,EAASM,SAASF,GAAY,CACpC,MAAMG,QAAaJ,EAAOK,UACpBC,QAAmBN,EAAOO,gBAC1BC,QAAuBR,EAAOS,oBAE9BC,EAA0B,CAC5BJ,iBAAkBA,EAAWK,cAC7BC,iBAAkBC,QAAQC,IACtBN,EAAeO,KAAKC,GAAMA,EAAEL,iBAEhCM,eAAgBpB,EAASoB,SAAShB,IAGlCiB,OAAOC,OAAOpB,EAAQK,GACtBL,EAAOK,GAAMxB,KAAK8B,GAElBX,EAAOK,GAAQ,CAACM,E,EAK5B,OAAOX,CACX,CAEQ7B,oBACJkD,GAEA,MAAMvB,QAAiB,IAAAC,kBACnB,8BAGEuB,EAAgC,GACtC,IAAK,MAAMC,KAASF,EAAQ,CACxB,MAAMnB,QAAkBqB,EAAMpB,eAC9B,SAAUL,EAASM,SAASF,GAAY,CACpC,MAAMG,QAAakB,EAAMjB,UACnBkB,QAAaD,EAAME,UACnBC,QAAiBF,EAAKZ,cAEtBe,EAAiC,CACnC,UAAG3F,QAAQ4F,eAAe,EAAAC,WAAWC,sBAE/BhC,EAASoB,SAAShB,IACxByB,EAAY9C,KACR,UAAG7C,QAAQ4F,eAAe,EAAAC,WAAWE,sBAInCjC,EAASkC,QAAQ9B,IACvByB,EAAY9C,KACR,UAAG7C,QAAQ4F,eAAe,EAAAC,WAAWI,kBAI7C,IAAIC,EAAc,UAAGlG,QAAQmG,0BACzBR,EACAtB,OACA+B,EACA3D,KAAK4D,yBAAyBX,GAAU,QACxCU,GAGJF,EAAc,UAAGI,2BACbJ,EACA,UAAGL,WAAWU,wBACd,6BAA6BlC,wBAC7B,GAGJiB,EAAIzC,KACA,UAAGyD,2BACCJ,EACA,UAAGL,WAAWW,uBACd,+BAA+BhB,EAAKZ,qBACpC,G,EAMhB,OAAOU,CACX,CAEQnD,4BACJsE,GAEA,MAAM3C,QAAiB,IAAAC,kBACnB,8BAGJ,aACW0C,EAAUC,qBACV5C,EAAS6C,iBAAiBF,EAAUtC,eAEnD,CAEQyC,2BACJ,MAAMV,EAAc,UAAGlG,QAAQ6G,6BAC3B,CAAC,UAAG7G,QAAQ4F,eAAe,UAAGC,WAAWiB,iBACzC,GACA,UAAG9G,QAAQ+G,YACP,CACI,UAAG/G,QAAQgH,0BACP,UAAGhH,QAAQiH,qBACP,UAAGjH,QAAQkH,cACX,GACA,OAIZ,IAIR,OAAO,UAAGZ,2BACNJ,EACA,UAAGL,WAAWW,uBACd,iHAEA,EAER,CAEQrE,0BACJgF,GAEA,MAAMrD,QAAiB,IAAAC,kBACnB,8BAEEqD,EAAoB,GAE1B,IAAK,MAAMC,KAAeF,EAAc,CACpC,MAAMjD,QAAkBmD,EAAYlD,eACpC,SAAUL,EAASM,SAASF,GAAY,CACpC,MAAMO,QAAuB4C,EAAY3C,oBACzC0C,EAAMvE,WACIiC,QAAQC,IACVN,EAAeO,KAAKC,GAAMA,EAAEL,iB,EAM5C,MAAM0C,EAAiBF,EAAMpC,KAAI,CAACuC,EAAGC,KACjC,MAAMC,EAASF,EAAEvC,IAAIvC,KAAKiF,iBAAiBC,KAAKlF,OAChD,IAAIyD,EAAc,UAAGlG,QAAQ6G,6BACzB,CAAC,UAAG7G,QAAQ4F,eAAe,UAAGC,WAAWC,gBACzC2B,OACArB,GA2BJ,OAzBU,IAANoB,IACAtB,EAAc,UAAGI,2BACbJ,EACA,UAAGL,WAAWU,wBACd,uDACA,IAIJgB,EAAE3E,OAAS,IACXsD,EAAc,UAAGI,2BACbJ,EACA,UAAGL,WAAWW,uBACd,MACIe,EACKvC,KACG,CAACC,EAAGuC,IACA,gBAAgBA,qBAAqBvC,SAE5CpE,KAAK,IACV,KACJ,IAIDqF,CAAW,IAiBtB,MAAO,IAdoBkB,EAAMpC,KAAI,CAACuC,EAAGC,IAC9B/E,KAAKmF,aACR,CACIrD,WAAY9B,KAAKF,UACjBsC,WAAY0C,EACZrC,UAAU,GAEd,cACAsC,GACA,GACA,QAI0BF,EACtC,CAEQO,qBAAqBrC,GACzB,OAAQA,GACJ,IAAK,UACD,MAAO,oBACX,IAAK,OACD,MAAO,iBACX,IAAK,OACD,MAAO,sBACX,IAAK,QACD,MAAO,kBACX,IAAK,MACD,MAAO,oBACX,IAAK,OACD,MAAO,iBACX,IAAK,QACD,MAAO,kBACX,IAAK,SACD,MAAO,mBACX,QACI,OAAOA,EAEnB,CAEQsC,YAAYtC,GAChB,MAAO,CACH,UACA,OACA,OACA,QACA,MACA,OACA,QACA,UACF7D,SAAS6D,EACf,CAEQa,yBACJ0B,EACAC,EACAC,GAA2B,GAE3B,MAAMC,EAAc1C,GACZyC,EACO,UAAGjI,QAAQmI,oBAAoB,CAClC3C,EACA,UAAGxF,QAAQoI,sBAAsB,UAAGpI,QAAQqI,gBAGzC7C,EAIf,OAAQuC,GACJ,IAAK,SACL,IAAK,mBACD,OAAOG,EAAW,UAAGlI,QAAQsI,wBAAwB,WAG7D,GAAIP,EAASQ,SAAS,MAClB,OAAOL,EACH,UAAGlI,QAAQwI,oBACP/F,KAAK4D,yBACD0B,EAASU,UAAU,EAAGV,EAASnF,OAAS,GACxCoF,KAMhB,MAAMM,EACFjE,IAEK5B,KAAKP,gBAAgBP,SAAS0C,IAC/B5B,KAAKiB,kBAAkBb,KAAKwB,GAGhC5B,KAAKkB,iBAAiBd,KAAKwB,GAC3B,MAAMqE,EAASrE,IAAS5B,KAAKF,WAAayF,EAC1C,OAAO,UAAGhI,QAAQsI,wBACdjE,IAAS5B,KAAKF,UACR8B,EAAKoE,UAAUpE,EAAKsE,YAAY,KAAO,IAClCD,EAAS,QAAU,IACxBrE,EAAKuE,WAAW,IAAK,KAC9B,EAGCC,EAAc,CAChBrD,KACGsD,KAEH,MAAM1B,EAAuB,CACzB,UAAGpH,QAAQ+I,sBAAsBvD,IASrC,OANK/C,KAAKqF,YAAYC,IAAaE,GAC/Bb,EAAMvE,KACF,UAAG7C,QAAQoI,sBAAsB,UAAGpI,QAAQqI,eAI/CL,EAIE,UAAGhI,QAAQmI,oBAAoB,CAClCG,EAAwB7F,KAAKoF,qBAAqBE,OAC/Ce,EAAgB9D,KAAKuC,GACpB,UAAGvH,QAAQ+I,sBAAsBxB,QAElCH,IARI,UAAGpH,QAAQmI,oBAAoBf,EASxC,EAGN,OAAQW,GACJ,IAAK,MACL,IAAK,oBACL,IAAK,QACL,IAAK,kBACL,IAAK,SACL,IAAK,mBACL,IAAK,OACL,IAAK,iBACL,IAAK,QACL,IAAK,kBACD,OAAOc,EAAY,EAAAhD,WAAWmD,eAClC,IAAK,OACL,IAAK,iBACD,OAAOH,EACH,EAAAhD,WAAWmD,cACX,EAAAnD,WAAWoD,eAEnB,IAAK,OACL,IAAK,sBACL,IAAK,mBACD,OAAOf,EACH,UAAGlI,QAAQ+I,sBAAsB,EAAAlD,WAAWqD,gBAEpD,IAAK,UACL,IAAK,oBACD,OAAOL,EAAY,EAAAhD,WAAWsD,gBAClC,IAAK,OACL,IAAK,iBACD,OAAO,UAAGnJ,QAAQ+I,sBAAsB,EAAAlD,WAAWuD,aACvD,IAAK,mBAED,OADA3G,KAAKgB,qBAAsB,EACpByE,EACH,UAAGlI,QAAQsI,wBAAwB,oBAE3C,QACI,OAAOJ,EAAWI,EAAwBP,IAEtD,CAEQL,iBACJ2B,EACAC,GAEA,MAAMjF,EAAO,MAAQiF,EACf9D,EAAO/C,KAAK4D,yBAAyBgD,GAAO,GAClD,OAAO,UAAGrJ,QAAQuJ,gCACdnD,OACAA,EACA/B,OACA+B,EACAZ,EAER,CAEQgE,kBAAkB/B,GACtB,OAAOA,EAAO5C,WAAWG,IAAIvC,KAAKiF,iBAAiBC,KAAKlF,MAC5D,CAEQmB,2BAA2BsC,GAC/B,MACI,MACAA,EAAYrB,WACPG,KAAI,CAACC,EAAGuC,IAAM,gBAAgBA,qBAAqBvC,SACnDpE,KAAK,IACV,qCAAqCqF,EAAY3B,gBAEzD,CAEQqD,aACJ6B,EACApF,EACAmD,EACAkC,EACAC,GAEA,MAAMC,EAAY,UAAG5J,QAAQ4F,eACzB,UAAGC,WAAWC,eAEZ+D,EAAY,UAAG7J,QAAQ4F,eACzB,UAAGC,WAAWE,eAGZ7B,EAA2B,CAAC0F,GAC9BH,EAAEvE,UACFhB,EAAUrB,KAAKgH,GAGnB,IAAItF,EAAa9B,KAAK4D,yBAClBoD,EAAElF,YACF,GACCoF,GAEAD,IACDnF,EAAa,UAAGvE,QAAQsI,wBACpB,UAAGtI,QAAQ8J,iBAAiB,WAC5B,CAACvF,KAIT,IAAI2B,EAAc,UAAGlG,QAAQ+J,wBACzB7F,OACAkC,EACA/B,GAAQqF,EAAS,OAAS,SAC1BtD,OACAA,EACA3D,KAAK+G,kBAAkBC,GACvBlF,OACA6B,GAYJ,OATU,IAANoB,IACAtB,EAAc,UAAGI,2BACbJ,EACA,UAAGL,WAAWU,wBACd,8BAA8BlC,wBAC9B,IAID,UAAGiC,2BACNJ,EACA,UAAGL,WAAWW,uBACdhD,EAA8BwG,oBAAoBP,IAClD,EAER,CAEQQ,cACJhG,EACAI,GAEA,MAAMiB,EAA8B,GAEpC,IAAK,IAAIkC,EAAI,EAAGA,EAAIvD,EAAOrB,OAAQ4E,IAAK,CACpC,MAAMiC,EAAIxF,EAAOuD,GAEXmC,EAAoBpG,EAAqB5B,SAAS0C,GACxDiB,EAAIzC,KACAJ,KAAKmF,aAAa6B,EAAGpF,EAAMmD,GAAG,EAAOmC,GACrClH,KAAKmF,aAAa6B,EAAGpF,EAAMmD,GAAG,EAAMmC,G,CAI5C,OAAOrE,CACX,CAEQ4E,uBACJ,MAAMC,EAAW3C,IACb,MAAM4C,EAA+B3H,KAAKF,UAAU8H,MAAM,KACpDC,EAAiC9C,EAAE6C,MAAM,KAE/C,IAAK,IAAIE,EAAI,EAAGA,EAAIH,EAAUxH,QACtB0H,EAAYC,KAAOH,EAAUG,GADCA,IAE9BH,EAAUG,GAAK,KACfD,EAAYC,GAAK,KAMzB,MACI,KACAH,EACKI,QAAQ5I,KAAQA,IAChBoD,KAAI,IAAM,KACVnE,KAAK,OACVyJ,EAAYE,QAAQ5I,KAAQA,IAAGf,KAAK,IACvC,EAOL,OAAO4B,KAAKkB,iBACP6G,QAAQhD,GAAMA,GAAK/E,KAAKF,YACxBiI,QANU,CAAIC,EAAUnB,EAAeoB,IACjCA,EAAKC,QAAQF,KAAWnB,IAM9BtE,KAAKwC,GACF,UAAGxH,QAAQ4K,6BACPxE,EACA,UAAGpG,QAAQ6K,oBACP,OACAzE,EACA,UAAGpG,QAAQ8K,mBAAmB,CAC1B,UAAG9K,QAAQ+K,uBACP,EACA,UAAG/K,QAAQ8J,iBACPtC,EAAEiB,UAAUjB,EAAEmB,YAAY,KAAO,IAErC,UAAG3I,QAAQ8J,iBACPtC,EAAEoB,WAAW,IAAK,UAKlC,UAAG5I,QAAQgL,oBAAoBb,EAAQ3C,MAGvD,CAEQyD,aACJ,MAAMC,EAAiB,CACnB,UAAGlL,QAAQ+K,uBACP,OACA3E,EACA,UAAGpG,QAAQ8J,iBAAiB,gBAEhC,UAAG9J,QAAQ+K,uBACP,OACA3E,EACA,UAAGpG,QAAQ8J,iBAAiB,eAIhCrH,KAAKgB,qBACLyH,EAAerI,KACX,UAAG7C,QAAQ+K,uBACP,OACA3E,EACA,UAAGpG,QAAQ8J,iBAAiB,qBAKxC,MAAMqB,EAAU,UAAGnL,QAAQ8K,mBAAmBI,GAC9C,OAAO,UAAGlL,QAAQ4K,6BACdxE,EACA,UAAGpG,QAAQ6K,oBAAmB,OAAOzE,EAAW+E,GAChD,UAAGnL,QAAQgL,oBAAoB,eAEvC,CAEQI,mBACJC,EACAC,GAEA,MAAMC,EAAY,UAAGvL,QAAQwL,uBACzB,CAAC,UAAGxL,QAAQ4F,eAAe,UAAGC,WAAW4F,gBACzCJ,OACAjF,EACA,CACI,UAAGpG,QAAQ0L,qBAAqB,UAAG7F,WAAW8F,eAAgB,CAC1D,UAAG3L,QAAQ4L,kCACP,UAAG5L,QAAQ8J,iBACP,sBAAsBuB,YAAqB5I,KAAKF,oBAEpD6D,MAIZkF,EAAwB,CAAC7I,KAAKmE,4BAA8B,IAGhE,MAAO,CACH,UAAGN,2BACCiF,EACA,EAAA1F,WAAWW,uBACX,eAAe/D,KAAKF,0FAEA8I,uQAGpB,GAEJ,UAAGrL,QAAQ6L,oBACP,UAAG7L,QAAQ8J,iBAAiBuB,IAGxC,CAEQS,QAAQC,GACZ,OAAOA,EACF/G,KACIgH,GACIA,GACG,UACKC,cAAc,CAAEC,QAAS,UAAGC,YAAYC,WACxCC,UACG,UAAGC,SAASC,YACZP,EACA/I,IAEZ,KAEPpC,KAAK,KACd,CAOOsB,iBACH,GAAIM,KAAKP,gBAAgBP,SAASc,KAAKF,WACnC,MAAO,GAGXE,KAAKP,gBAAgBW,KAAKJ,KAAKF,WAC3BE,KAAKJ,kBACLI,KAAKJ,iBAAiBI,KAAKF,WAG/B,MACMiK,SADc,IAAAzI,kBAAiBtB,KAAKF,YACxBkK,MAEZpB,EAAa5I,KAAKF,UAAUkG,UAC9BhG,KAAKF,UAAUoG,YAAY,KAAO,GAehCtD,SAAgBmH,EAAIE,aAAalC,QAZvC,SACIC,EACAnB,EACAoB,GAEA,OACIA,EAAKiC,WACAC,GAAOnC,EAAMoC,gBAAkBD,EAAGC,kBACjCvD,CAEd,IAGMzF,QAAgB2I,EAAIM,aAEpBC,QAAwCtK,KAAKuK,cAC/C3H,GAGE4H,QACIzJ,EAA8B0J,eAAerJ,GACvD,IAAK,MAAOsJ,EAAKlJ,KAAWkB,OAAOiI,QAAQH,GACvCF,EAAalK,QAAQJ,KAAKwH,cAAchG,EAAQkJ,IAGpD,MAAM7B,QAA8B7I,KAAK6I,sBAAsBkB,GAC/D,IAAKlB,EAAuB,CACxB,MAAMnE,QAAqBqF,EAAIa,0BACzBC,QAA8B7K,KAAK8K,oBACrCpG,GAEJ4F,EAAalK,QAAQyK,E,CAGzB,IAAIE,EAAU,UAAGxN,QAAQwL,uBACrB,CACI,UAAGxL,QAAQ4F,eAAe,UAAGC,WAAW4F,eACxC,UAAGzL,QAAQ4F,eAAe,UAAGC,WAAW4H,iBAE5CpC,EAAa,aACbjF,EACA,CACI,UAAGpG,QAAQ0L,qBAAqB,UAAG7F,WAAW8F,eAAgB,CAC1D,UAAG3L,QAAQ4L,kCACP,UAAG5L,QAAQ8J,iBAAiB,kBAC5B1D,MAIZ2G,GAGJS,EAAU,UAAGlH,2BACTkH,EACA,UAAG3H,WAAWW,uBACd,0DAA0D6E,uGAE1D,GAGJ,MAAMqC,EAAajL,KAAKqJ,QAAQ,CAC5BrJ,KAAKwI,gBACFxI,KAAKyH,uBACR,KACAsD,EACA,QACG/K,KAAK2I,mBAAmBC,EAAYC,KAGrChG,EAA2B,GACjC,IAAK,MAAMqI,KAAYlL,KAAKiB,kBAAmB,CAC3C,MAAMlB,EAAY,IAAIgB,EAClBmK,EACAlL,KAAKJ,iBACLI,KAAKP,iBAEHQ,QAAkBF,EAAUG,WAClC2C,EAAIzC,QAAQH,E,CAQhB,OALA4C,EAAIzC,KAAK,CACLwB,KAAM5B,KAAKF,UACXqL,SAAUF,IAGPpI,CACX,CAQO1B,kBACH3B,EACA4L,GAEA,IAAK,MAAM3H,KAAejE,EAAc,CACpC,MAAMgD,EAAIiB,EAAY7B,KAAKgG,MAAM,KACjCpF,EAAEA,EAAErC,OAAS,GAAKqC,EAAEA,EAAErC,OAAS,GAAK,MAEpC,MAAMkL,EAAW,UAAKjN,KAAKgN,KAAc5I,SACnC,UAAG8I,SAASC,MAAM,UAAKC,QAAQH,GAAW,CAC5CI,WAAW,UAET,UAAGH,SAASI,UAAUL,EAAU5H,EAAY0H,SAAU,CACxDQ,SAAU,Q,CAGtB,EAtvBJ,W,0BCpGA,IAAYC,E,mFAAZ,SAAYA,GAER,gBAEA,gBAEA,gBAEA,gBAEA,gBAEA,YAEA,aACH,CAfD,CAAYA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KAiBvBlJ,OAAOmJ,OAAOD,GAwBd,oB,gqCC/CA,YACI,6EAAAA,WAAW,IACX,4EAAAE,UAAU,IACV,mFAAAC,iBAAiB,IACjB,gFAAAC,cAAc,IACd,2EAAAC,SAAS,IACT,sFAAAC,oBAAoB,IACpB,kFAAAC,gBAAgB,IAgBpB,YACA,kBACA,UAAeC,EACf,aAAS,wDAAAC,IAAA,oBAAA9M,cAAc,IACvB,aAAS,wDAAA8M,IAAA,oBAAAC,cAAc,IAAE,4DAAAD,IAAA,oBAAAE,kBAAkB,IAC3C,kBACS,EAAAxL,8BADF,UAEP,aAAS,mGAAAyL,iCAAiC,G,uPC9B1C,eAQA,SAKA,IAAIC,EAA4B,KA8EhC,SAAgBC,EAAUC,GACtB,OAAKF,IACDA,EAAe,IAAI,EAAArN,KACfuN,GAASC,QACTD,GAASE,QACTF,GAASG,KACTH,GACA,IAAApN,gBAAeoN,GAASI,qBAAsB,IAC9C,IAAAC,kBAAiBL,GAASI,qBAAsB,KAG7C,EAIf,CAkKA,SAAgBE,EAAgBC,GAC5BR,IACAD,EAAcQ,gBAAgBC,EAClC,CAuDA,IAAiBC,EA3OjB,cAqCA,4BAEI,OADAT,IACOD,EAAcW,WACzB,EAUA,0BAA+BA,GAC3BV,IACAD,EAAcW,YAAcA,CAChC,EAmEA,uBAEEtN,GAEE,OADA4M,IACOD,EAAcY,YAAYvN,EACrC,EAKA,4BAEEA,GAEE,OADA4M,IACOD,EAAcnL,iBAAiBxB,EAC1C,EA0CA,oBAuCA,wBACIwN,EACAC,GAGA,OADAb,IACOD,EAAce,aAAaF,EAAUC,EAChD,GAaiBJ,EAAA,EAAAA,YAAA,EAAAA,UAAS,KAINM,OAAhB,SAAuBP,GACnBD,EAAgBC,EACpB,EAOgB,EAAAb,IAAhB,WAEI,OADAK,IACOD,EAAciB,UACzB,GA4Ea,EAAAC,SAAA,EAAAA,OAAM,KAsDHC,eAAhB,SACID,EACAE,GAGA,OADAnB,IACOD,EAAcqB,mBAAmBH,EAAQE,EACpD,EAwKJ,oBACIE,EACA3M,GAEAsL,IACA,MAAMsB,EAAoCtL,OAAOuL,OAAO,MAExD,IAAK,MAAOrM,EAAMJ,KAAWkB,OAAOiI,QAAQvJ,GACxC4M,EAAapM,GAAQ,CACjBsM,EACAC,KACGC,KAEH,GAAIF,EACA,MAAMA,EAGV,IAEIC,EAAS,KADG3M,KAAU4M,G,CAExB,MAAOjP,GACDA,aAAalB,MACbkQ,EAAShP,GAETgP,EAAS,IAAIlQ,MAAMkB,EAAEH,Y,GAMrC,OAAOyN,EAAc4B,qBACjBN,EACAC,EAER,EAMA,6BACI,OAAOvB,CACX,C,u1BChrBA,iBACA,YACA,aAEM,SAAEpO,EAAQ,KAAEC,GAAST,QAErByQ,EAAiB,6BACjBC,EAAoB,wBAE1B,SAASC,EAAUC,EAAc1B,GAC7B,MAAM2B,EAAQ,UAAKtQ,KAAKL,UAAW0Q,EAAO,SAE1C,GAAI,UAAGvQ,WAAWwQ,GAKd,OAJI3B,GACA4B,QAAQC,KAAK,sDAGVF,EACJ,CACH,MAAMjR,EAASgR,EAAKtI,WAAW,IAAK,KAAK0I,QAAQ,OAAQ,eAEzD,IAAIhM,EAWJ,OAPIA,EAFA,SAA2B,QAAwBiM,QAE7C,QAAwBA,QAAQrR,GAEhB,eAAAA,GAGtBsP,IACAlK,EAAMA,EAAIgM,QAAQP,EAAgBC,IAC/B1L,C,CAEf,CAEA,SAASkM,IACL,OAAO,IAAI9Q,MAAM,yBAAyBI,KAAYC,IAC1D,CAiBA,4BAAiCyO,GAC7B,OAAQ1O,GACJ,IAAK,UACD,OAAQC,GACJ,IAAK,QACD,OAAOkQ,EAAU,qBAAsBzB,GAC3C,IAAK,MACD,OAAOyB,EACH,wBACAzB,GAER,QACI,MAAMgC,IAElB,IAAK,QACD,OAAOP,EAAU,cAAclQ,SAAayO,GAChD,IAAK,SACD,OAAOyB,EAAU,eAAelQ,IAAQyO,GAC5C,IAAK,UACD,OAAOyB,EAAU,gBAAgBlQ,IAAQyO,GAC7C,IAAK,QACD,OAAQzO,GACJ,IAAK,MACL,IAAK,QACD,OAAOkQ,EACH,cAAclQ,KAxCtC,WAEI,GAAKT,QAAQc,QAA8C,mBAA7Bd,QAAQc,OAAOC,UAMtC,CACH,MAAM,oBAAEC,GAAyBhB,QAAQc,OAAOC,YAC3CE,OACL,OAAQD,C,CARR,IACI,OAAO,IAAAV,cAAa,eAAgB,QAAQe,SAAS,O,CACvD,MAAOC,GACL,OAAO,C,CAOnB,CA2B8CT,GAAW,OAAS,QAC1CqO,GAER,IAAK,MACD,OAAOyB,EACH,2BACAzB,GAER,QACI,MAAMgC,IAElB,QACI,MAAMA,IAElB,EAEA,0BAA+BhC,GAC3B,IAAIiC,EAAM,UAAK5Q,KAAKL,UAAW,KAAM,WAAY,QAAS,QACtDgP,IACAiC,EAAMA,EAAIH,QAAQP,EAAgBC,IAEtC,MAAMU,EAAQ,UAAKC,KAAK,QAAS,CAAEC,IAAKH,IACxC,GAAqB,IAAjBC,EAAM9O,OACN,MAAM,IAAIlC,MAAM,wBAAwB+Q,KAExC,OAAO,UAAK5Q,KAAK4Q,EAAKC,EAAM,GAEpC,C,u7BC3GA,wDACA,qCACA,gDACA,0CAKA,wCAWMG,UAAY,IACdC,KAAK,0CACHC,YAAc,IAChBD,KAAK,gDAEHE,QAA4CC,IAC9CA,EAAQC,WAAW,aAAc,CAC7BC,SAAU,+CACV3M,KAAM,WAGVyM,EAAQC,WAAW,SAAU,CACzBC,SAAU,kBACV3M,KAAM,WAGVyM,EAAQG,OAAO,YAAa,CACxBC,MAAO,KACP7M,KAAM,SACN2M,SAAU,wBACZ,EAGAG,QAA8BnQ,OAChCC,aACAU,SACA8M,gBAEA,IAAI2C,EAAsB,KAC1B,IACI,MAAMC,EAAY,aAAAC,YAAYC,OAC9B,KAAAvD,aAEIS,GACA,WAAKA,UAAUM,OAAON,GAG1B,MAAM+C,QAAcZ,cACda,QAAYf,YAElBT,QAAQyB,IACJ,YAAYF,EAAMG,WAAW,kBAAkBH,EAAMI,YACjD,IAAM,eAAAzD,sCAId,MAAMJ,GAAe,KAAA8D,mBACf7C,EAAa,WAAKP,UAAUd,MAC9BqB,EAAWvN,OAAS,GACpBwO,QAAQyB,IACJ,4BAA4BF,EAAMG,WAC9B5D,EAAaI,2BACGa,EACfnL,KAAKuF,GAAMoI,EAAMG,WAAWvI,KAC5B1J,KAAK,SAIlBuQ,QAAQyB,IACJ,sBAAsBzQ,EACjB4C,KAAKiO,GAAMN,EAAMO,cAAcD,KAC/BpS,KACG,4CACoC8R,EAAMG,WAC9C,eAAKK,UAAUrQ,OAIvByP,EAAUK,IAAMQ,QAEhB,MAAMlR,EAA4B,GAClC,IAAImR,EAA0B,EAC1B/Q,EAAsB,EAEtBgR,EAAiC,EACjCC,EAA4B,GAChC,MAAMC,EAAsBC,aAAY,KACpCH,GAA0B,EAC1BI,GAAS,GACV,KAEGA,EAAU,KACZnB,EAASoB,KAAOhB,EAAMiB,KAClB,iBAAiBjB,EAAMkB,OACnBP,cACSX,EAAMmB,MAAM,kBAAkBnB,EAAMG,WAC7CO,cACSV,EAAMmB,MACf,yBACkBnB,EAAMO,cAAcK,KAC7C,EAGL,IAAK,MAAMhR,KAAaH,EAAY,CAChC,MAAMI,EAAY,IAAI,GAAAgB,8BAClBjB,GACC8B,IACGkP,EAAoBlP,EACpBgP,IACAK,GAAS,GAEbxR,GAEEQ,QAAkBF,EAAUG,WAClCL,GAAeI,EAAUE,OAEzB2P,EAASoB,KAAO,uBACV,GAAAnQ,8BAA8BT,KAAKL,EAAWI,E,CAGxDiR,cAAcP,GACd,MAAMQ,IAAgB,aAAAvB,YAAYC,MAAQF,GAAa,KAAMyB,QAAQ,GACrE1B,EAAS2B,QACL,uBAAuBvB,EAAMwB,WACzB7R,iBACYqQ,EAAMwB,WAAWH,a,CAEvC,MAAOpS,GACL2Q,GAAS6B,KAAK,6BACdhD,QAAQ3Q,MAAMmB,GACdtB,QAAQ+T,KAAK,E,GAIrB,gBACKpC,QAAc,6BAA6B,EAAOD,QAASM,SAC3DgC,O,2HCjJL,eASA,iBAAOnS,iBACH,MAAMoS,QAAe,IAAAxQ,kBAAiB,oBACtC,aAAawQ,EAAOC,YAAY,eACpC,EAgBA,gCAEI,OADe,IAAA1E,aAAY,oBACb2E,gBAAgB,eAClC,C,UC/BA,SAASC,EAAoBC,GAC5B,IAAI/S,EAAI,IAAIlB,MAAM,uBAAyBiU,EAAM,KAEjD,MADA/S,EAAEgT,KAAO,mBACHhT,CACP,CACA8S,EAAoBG,KAAO,IAAM,GACjCH,EAAoBnD,QAAUmD,EAC9BA,EAAoBI,GAAK,IACzB5U,EAAOD,QAAUyU,C,uBCRjBxU,EAAOD,QAAU8U,QAAQ,O,qBCAzB7U,EAAOD,QAAU8U,QAAQ,a,uBCAzB7U,EAAOD,QAAU8U,QAAQ,Q,sBCAzB7U,EAAOD,QAAU8U,QAAQ,gB,uBCAzB7U,EAAOD,QAAU8U,QAAQ,K,sBCAzB7U,EAAOD,QAAU8U,QAAQ,O,sBCAzB7U,EAAOD,QAAU8U,QAAQ,a,4lGCCrBC,yBAA2B,CAAC,EAGhC,SAASC,oBAAoBC,GAE5B,IAAIC,EAAeH,yBAAyBE,GAC5C,QAAqB9O,IAAjB+O,EACH,OAAOA,EAAalV,QAGrB,IAAIC,EAAS8U,yBAAyBE,GAAY,CACjDJ,GAAII,EACJE,QAAQ,EACRnV,QAAS,CAAC,GAUX,OANAoV,oBAAoBH,GAAUI,KAAKpV,EAAOD,QAASC,EAAQA,EAAOD,QAASgV,qBAG3E/U,EAAOkV,QAAS,EAGTlV,EAAOD,OACf,CCzBAgV,oBAAoBM,EAAI,CAACC,EAAKC,IAAUtQ,OAAOuQ,UAAUC,eAAeL,KAAKE,EAAKC,GCAlFR,oBAAoBW,IAAO1V,IAC1BA,EAAO2V,MAAQ,GACV3V,EAAO4V,WAAU5V,EAAO4V,SAAW,IACjC5V,GCHR+U,oBAAoBhQ,EAAI,GCGxB,IAAI8Q,oBAAsBd,oBAAoB,K,4BvBO9C","sources":["webpack://java/webpack/universalModuleDefinition","webpack://java/./java.linux-x64-gnu.node","webpack://java/./native.js","webpack://java/./ts-src/TypescriptBulkDefinitionGenerator.ts","webpack://java/./ts-src/TypescriptDefinitionGenerator.ts","webpack://java/./ts-src/definitions.ts","webpack://java/./ts-src/index.ts","webpack://java/./ts-src/java.ts","webpack://java/./ts-src/nativeLib.ts","webpack://java/./ts-src/scripts/cli.ts","webpack://java/./ts-src/util.ts","webpack://java/./ts-src/ sync","webpack://java/external commonjs \"glob\"","webpack://java/external commonjs \"typescript\"","webpack://java/external commonjs \"yargs\"","webpack://java/external node-commonjs \"child_process\"","webpack://java/external node-commonjs \"fs\"","webpack://java/external node-commonjs \"path\"","webpack://java/external node-commonjs \"perf_hooks\"","webpack://java/webpack/bootstrap","webpack://java/webpack/runtime/hasOwnProperty shorthand","webpack://java/webpack/runtime/node module decorator","webpack://java/webpack/runtime/publicPath","webpack://java/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"java\"] = factory();\n\telse\n\t\troot[\"java\"] = factory();\n})(global, () => {\nreturn ","\ntry {\n  process.dlopen(module, __dirname + require(\"path\").sep + __webpack_public_path__ + \"java.linux-x64-gnu.node\");\n} catch (error) {\n  throw new Error('node-loader:\\n' + error);\n}\n","const { existsSync, readFileSync } = require('fs')\nconst { join } = require('path')\n\nconst { platform, arch } = process\n\nlet nativeBinding = null\nlet localFileExisted = false\nlet loadError = null\n\nfunction isMusl() {\n  // For Node 10\n  if (!process.report || typeof process.report.getReport !== 'function') {\n    try {\n      const lddPath = require('child_process').execSync('which ldd').toString().trim();\n      return readFileSync(lddPath, 'utf8').includes('musl')\n    } catch (e) {\n      return true\n    }\n  } else {\n    const { glibcVersionRuntime } = process.report.getReport().header\n    return !glibcVersionRuntime\n  }\n}\n\nswitch (platform) {\n  case 'android':\n    switch (arch) {\n      case 'arm64':\n        localFileExisted = existsSync(join(__dirname, 'java.android-arm64.node'))\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.android-arm64.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-android-arm64')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      case 'arm':\n        localFileExisted = existsSync(join(__dirname, 'java.android-arm-eabi.node'))\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.android-arm-eabi.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-android-arm-eabi')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      default:\n        throw new Error(`Unsupported architecture on Android ${arch}`)\n    }\n    break\n  case 'win32':\n    switch (arch) {\n      case 'x64':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.win32-x64-msvc.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.win32-x64-msvc.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-win32-x64-msvc')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      case 'ia32':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.win32-ia32-msvc.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.win32-ia32-msvc.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-win32-ia32-msvc')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      case 'arm64':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.win32-arm64-msvc.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.win32-arm64-msvc.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-win32-arm64-msvc')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      default:\n        throw new Error(`Unsupported architecture on Windows: ${arch}`)\n    }\n    break\n  case 'darwin':\n    localFileExisted = existsSync(join(__dirname, 'java.darwin-universal.node'))\n    try {\n      if (localFileExisted) {\n        nativeBinding = require('./java.darwin-universal.node')\n      } else {\n        nativeBinding = __non_webpack_require__('java-bridge-darwin-universal')\n      }\n      break\n    } catch {}\n    switch (arch) {\n      case 'x64':\n        localFileExisted = existsSync(join(__dirname, 'java.darwin-x64.node'))\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.darwin-x64.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-darwin-x64')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      case 'arm64':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.darwin-arm64.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.darwin-arm64.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-darwin-arm64')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      default:\n        throw new Error(`Unsupported architecture on macOS: ${arch}`)\n    }\n    break\n  case 'freebsd':\n    if (arch !== 'x64') {\n      throw new Error(`Unsupported architecture on FreeBSD: ${arch}`)\n    }\n    localFileExisted = existsSync(join(__dirname, 'java.freebsd-x64.node'))\n    try {\n      if (localFileExisted) {\n        nativeBinding = require('./java.freebsd-x64.node')\n      } else {\n        nativeBinding = __non_webpack_require__('java-bridge-freebsd-x64')\n      }\n    } catch (e) {\n      loadError = e\n    }\n    break\n  case 'linux':\n    switch (arch) {\n      case 'x64':\n        if (isMusl()) {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-x64-musl.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-x64-musl.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-x64-musl')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        } else {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-x64-gnu.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-x64-gnu.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-x64-gnu')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        }\n        break\n      case 'arm64':\n        if (isMusl()) {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-arm64-musl.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-arm64-musl.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-arm64-musl')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        } else {\n          localFileExisted = existsSync(\n            join(__dirname, 'java.linux-arm64-gnu.node')\n          )\n          try {\n            if (localFileExisted) {\n              nativeBinding = require('./java.linux-arm64-gnu.node')\n            } else {\n              nativeBinding = __non_webpack_require__('java-bridge-linux-arm64-gnu')\n            }\n          } catch (e) {\n            loadError = e\n          }\n        }\n        break\n      case 'arm':\n        localFileExisted = existsSync(\n          join(__dirname, 'java.linux-arm-gnueabihf.node')\n        )\n        try {\n          if (localFileExisted) {\n            nativeBinding = require('./java.linux-arm-gnueabihf.node')\n          } else {\n            nativeBinding = __non_webpack_require__('java-bridge-linux-arm-gnueabihf')\n          }\n        } catch (e) {\n          loadError = e\n        }\n        break\n      default:\n        throw new Error(`Unsupported architecture on Linux: ${arch}`)\n    }\n    break\n  default:\n    throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`)\n}\n\nif (!nativeBinding) {\n  if (loadError) {\n    throw loadError\n  }\n  throw new Error(`Failed to load native binding`)\n}\n\nconst { Java, JavaInterfaceProxy, StdoutRedirect, getJavaLibPath } = nativeBinding\n\nmodule.exports.Java = Java\nmodule.exports.JavaInterfaceProxy = JavaInterfaceProxy\nmodule.exports.StdoutRedirect = StdoutRedirect\nmodule.exports.getJavaLibPath = getJavaLibPath\n","import TypescriptDefinitionGenerator, {\n    ModuleDeclaration,\n    ProgressCallback,\n} from './TypescriptDefinitionGenerator';\n\n/**\n * Generates a lot of definitions for a lot of modules at once.\n * This caches the definitions for each module, so that if a module is used in multiple\n * other modules, it only needs to be generated once. This is a lot faster than generating\n * each module individually. It also generates the definitions in the correct order, so that\n * dependencies are always generated before the modules that depend on them.\n *\n * ## Example\n * ```ts\n * const generator = new TypescriptBulkDefinitionGenerator();\n *\n * // Generate definitions for the provided modules\n * await generator.generate([\n *      'java.lang.String',\n *      'java.util.List',\n *      'java.util.Map',\n *      'java.io.FileOutputStream',\n *      'java.io.FileInputStream',\n *      'java.io.File',\n *      'java.lang.System',\n * ]);\n *\n * // Save the definitions to a directory\n * await generator.save('javaDefinitions');\n * ```\n *\n * @see TypescriptDefinitionGenerator\n */\nexport class TypescriptBulkDefinitionGenerator {\n    private readonly declarations: ModuleDeclaration[] = [];\n    private readonly resolvedImports: string[] = [];\n\n    /**\n     * Generate the definitions for a module.\n     *\n     * @see TypescriptDefinitionGenerator.generate\n     * @param classnames the fully qualified names of the classes to generate\n     * @param progressCallback a callback that is called when a class is generated\n     * @returns the number of classes that were generated\n     */\n    public async generate(\n        classnames: string[],\n        progressCallback: ProgressCallback | null = null\n    ): Promise<number> {\n        let numResolved = 0;\n        for (const classname of classnames) {\n            const generator = new TypescriptDefinitionGenerator(\n                classname,\n                progressCallback,\n                this.resolvedImports\n            );\n            const generated = await generator.generate();\n            numResolved += generated.length;\n\n            this.declarations.push(...generated);\n        }\n\n        return numResolved;\n    }\n\n    /**\n     * Save the generated definitions to a directory.\n     *\n     * @see TypescriptDefinitionGenerator.save\n     * @param output the directory to save the definitions to\n     */\n    public async save(output: string): Promise<void> {\n        await TypescriptDefinitionGenerator.save(this.declarations, output);\n    }\n\n    /**\n     * Get the generated definitions.\n     */\n    public get moduleDeclarations(): ModuleDeclaration[] {\n        return this.declarations;\n    }\n}\n","import ts, { SyntaxKind } from 'typescript';\nimport { importClassAsync, JavaClass } from './.';\nimport fs from 'fs';\nimport path from 'path';\n\nconst sourceFile = ts.createSourceFile(\n    'source.ts',\n    '',\n    ts.ScriptTarget.Latest,\n    false,\n    ts.ScriptKind.TS\n);\n\nexport interface MethodDeclaration {\n    returnType: string;\n    parameters: string[];\n    isStatic: boolean;\n}\n\n/**\n * A java class declaration converted to typescript\n */\nexport interface ModuleDeclaration {\n    /**\n     * The fully-qualified class name\n     */\n    name: string;\n    /**\n     * The generated typescript code\n     */\n    contents: string;\n}\n\n/**\n * A TypescriptDefinitionGenerator progress callback method\n */\nexport type ProgressCallback = (classname: string) => void;\n\ndeclare class ModifierClass extends JavaClass {\n    public static isPublic(val: number): Promise<boolean>;\n    public static isStatic(val: number): Promise<boolean>;\n    public static isStaticSync(val: number): boolean;\n    public static isFinal(val: number): Promise<boolean>;\n    public static isAbstract(val: number): Promise<boolean>;\n}\n\ndeclare class TypeClass extends JavaClass {\n    public getTypeName(): Promise<string>;\n}\n\ndeclare class DeclaredMethodClass extends JavaClass {\n    public getModifiers(): Promise<number>;\n    public getName(): Promise<string>;\n    public getReturnType(): Promise<TypeClass>;\n    public getParameterTypes(): Promise<TypeClass[]>;\n}\n\ndeclare class DeclaredConstructorClass extends JavaClass {\n    public getModifiers(): Promise<number>;\n    public getParameterTypes(): Promise<TypeClass[]>;\n}\n\ndeclare class ClassClass extends JavaClass {\n    public getMethods(): Promise<DeclaredMethodClass[]>;\n    public getDeclaredConstructors(): Promise<DeclaredConstructorClass[]>;\n    public getFields(): Promise<FieldClass[]>;\n    public getModifiers(): Promise<number>;\n    public isInterface(): Promise<boolean>;\n}\n\ndeclare class FieldClass extends JavaClass {\n    public getModifiers(): Promise<number>;\n    public getName(): Promise<string>;\n    public getNameSync(): string;\n    public getType(): Promise<TypeClass>;\n}\n\n/**\n * A list of methods which probably never return null\n */\nconst nonNullReturnMethods: string[] = [\n    'toString',\n    'wait',\n    'getClass',\n    'hashCode',\n    'notify',\n    'notifyAll',\n    'equals',\n];\n\n/**\n * A class to generate typescript definitions for java classes.\n * Converts the given class and all of its dependencies to typescript.\n *\n * ## Example\n * ```ts\n * import { TypescriptDefinitionGenerator } from 'java-bridge';\n *\n * const generator = new TypescriptDefinitionGenerator('java.lang.String');\n * // Generate the typescript definitions\n * const definitions = await generator.generate();\n *\n * // Save the definitions to a directory\n * await TypescriptDefinitionGenerator.save(definitions, './project');\n * ```\n */\nexport default class TypescriptDefinitionGenerator {\n    private usesBasicOrJavaType: boolean = false;\n    private readonly additionalImports: string[] = [];\n    private readonly importsToResolve: string[] = [];\n\n    /**\n     * Create a new `TypescriptDefinitionGenerator` instance\n     *\n     * @param classname the fully-qualified name of the class to generate a typescript definition for\n     * @param progressCallback a callback method to be called every time a java class is\n     *                         converted to typescript\n     * @param resolvedImports a list of imports that have already been resolved.\n     *                        This is used to prevent converting a class multiple times\n     */\n    public constructor(\n        private readonly classname: string,\n        private readonly progressCallback: ProgressCallback | null = null,\n        private readonly resolvedImports: string[] = []\n    ) {}\n\n    private static async convertMethods(\n        methods: DeclaredMethodClass[]\n    ): Promise<Record<string, MethodDeclaration[]>> {\n        const Modifier = await importClassAsync<typeof ModifierClass>(\n            'java.lang.reflect.Modifier'\n        );\n\n        const result: Record<string, MethodDeclaration[]> = {};\n        for (const method of methods) {\n            const modifiers = await method.getModifiers();\n            if (await Modifier.isPublic(modifiers)) {\n                const name = await method.getName();\n                const returnType = await method.getReturnType();\n                const parameterTypes = await method.getParameterTypes();\n\n                const data: MethodDeclaration = {\n                    returnType: await returnType.getTypeName(),\n                    parameters: await Promise.all(\n                        parameterTypes.map((p) => p.getTypeName())\n                    ),\n                    isStatic: await Modifier.isStatic(modifiers),\n                };\n\n                if (Object.hasOwn(result, name)) {\n                    result[name].push(data);\n                } else {\n                    result[name] = [data];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private async convertFields(\n        fields: FieldClass[]\n    ): Promise<ts.PropertyDeclaration[]> {\n        const Modifier = await importClassAsync<typeof ModifierClass>(\n            'java.lang.reflect.Modifier'\n        );\n\n        const res: ts.PropertyDeclaration[] = [];\n        for (const field of fields) {\n            const modifiers = await field.getModifiers();\n            if (await Modifier.isPublic(modifiers)) {\n                const name = await field.getName();\n                const type = await field.getType();\n                const typeName = await type.getTypeName();\n\n                const tsModifiers: ts.ModifierLike[] = [\n                    ts.factory.createModifier(SyntaxKind.PublicKeyword),\n                ];\n                if (await Modifier.isStatic(modifiers)) {\n                    tsModifiers.push(\n                        ts.factory.createModifier(SyntaxKind.StaticKeyword)\n                    );\n                }\n\n                if (await Modifier.isFinal(modifiers)) {\n                    tsModifiers.push(\n                        ts.factory.createModifier(SyntaxKind.ReadonlyKeyword)\n                    );\n                }\n\n                let declaration = ts.factory.createPropertyDeclaration(\n                    tsModifiers,\n                    name,\n                    undefined,\n                    this.javaTypeToTypescriptType(typeName, true),\n                    undefined\n                );\n\n                declaration = ts.addSyntheticLeadingComment(\n                    declaration,\n                    ts.SyntaxKind.SingleLineCommentTrivia,\n                    ` ================== Field ${name} ==================`,\n                    true\n                );\n\n                res.push(\n                    ts.addSyntheticLeadingComment(\n                        declaration,\n                        ts.SyntaxKind.MultiLineCommentTrivia,\n                        `*\\n * Original type: '${await type.getTypeName()}'\\n `,\n                        true\n                    )\n                );\n            }\n        }\n\n        return res;\n    }\n\n    private async isAbstractOrInterface(\n        classType: ClassClass\n    ): Promise<boolean> {\n        const Modifier = await importClassAsync<typeof ModifierClass>(\n            'java.lang.reflect.Modifier'\n        );\n\n        return (\n            (await classType.isInterface()) ||\n            (await Modifier.isAbstract(await classType.getModifiers()))\n        );\n    }\n\n    private createPrivateConstructor(): ts.ClassElement {\n        const declaration = ts.factory.createConstructorDeclaration(\n            [ts.factory.createModifier(ts.SyntaxKind.PrivateKeyword)],\n            [],\n            ts.factory.createBlock(\n                [\n                    ts.factory.createExpressionStatement(\n                        ts.factory.createCallExpression(\n                            ts.factory.createSuper(),\n                            [],\n                            []\n                        )\n                    ),\n                ],\n                true\n            )\n        );\n\n        return ts.addSyntheticLeadingComment(\n            declaration,\n            ts.SyntaxKind.MultiLineCommentTrivia,\n            '*\\n * Private constructor to prevent instantiation\\n' +\n                ' * as this is either an abstract class or an interface\\n ',\n            true\n        );\n    }\n\n    private async convertConstructors(\n        constructors: DeclaredConstructorClass[]\n    ): Promise<ts.ClassElement[]> {\n        const Modifier = await importClassAsync<typeof ModifierClass>(\n            'java.lang.reflect.Modifier'\n        );\n        const types: string[][] = [];\n\n        for (const constructor of constructors) {\n            const modifiers = await constructor.getModifiers();\n            if (await Modifier.isPublic(modifiers)) {\n                const parameterTypes = await constructor.getParameterTypes();\n                types.push(\n                    await Promise.all(\n                        parameterTypes.map((p) => p.getTypeName())\n                    )\n                );\n            }\n        }\n\n        const tsConstructors = types.map((t, i) => {\n            const params = t.map(this.convertParameter.bind(this));\n            let declaration = ts.factory.createConstructorDeclaration(\n                [ts.factory.createModifier(ts.SyntaxKind.PublicKeyword)],\n                params,\n                undefined\n            );\n            if (i === 0) {\n                declaration = ts.addSyntheticLeadingComment(\n                    declaration,\n                    ts.SyntaxKind.SingleLineCommentTrivia,\n                    ` ================== Constructors ==================`,\n                    true\n                );\n            }\n\n            if (t.length > 0) {\n                declaration = ts.addSyntheticLeadingComment(\n                    declaration,\n                    ts.SyntaxKind.MultiLineCommentTrivia,\n                    '*\\n' +\n                        t\n                            .map(\n                                (p, i) =>\n                                    ` * @param var${i} original type: '${p}'\\n`\n                            )\n                            .join('') +\n                        ' ',\n                    true\n                );\n            }\n\n            return declaration;\n        });\n\n        const newInstanceMethods = types.map((t, i) => {\n            return this.createMethod(\n                {\n                    returnType: this.classname,\n                    parameters: t,\n                    isStatic: true,\n                },\n                'newInstance',\n                i,\n                false,\n                true\n            );\n        });\n\n        return [...newInstanceMethods, ...tsConstructors];\n    }\n\n    private primitiveToClassType(type: string): string {\n        switch (type) {\n            case 'boolean':\n                return 'java.lang.Boolean';\n            case 'byte':\n                return 'java.lang.Byte';\n            case 'char':\n                return 'java.lang.Character';\n            case 'short':\n                return 'java.lang.Short';\n            case 'int':\n                return 'java.lang.Integer';\n            case 'long':\n                return 'java.lang.Long';\n            case 'float':\n                return 'java.lang.Float';\n            case 'double':\n                return 'java.lang.Double';\n            default:\n                return type;\n        }\n    }\n\n    private isPrimitive(type: string): boolean {\n        return [\n            'boolean',\n            'byte',\n            'char',\n            'short',\n            'int',\n            'long',\n            'float',\n            'double',\n        ].includes(type);\n    }\n\n    private javaTypeToTypescriptType(\n        javaType: string,\n        isParam: boolean,\n        strictNullTypes: boolean = true\n    ): ts.TypeNode {\n        const createType = (type: ts.TypeNode): ts.TypeNode => {\n            if (strictNullTypes) {\n                return ts.factory.createUnionTypeNode([\n                    type,\n                    ts.factory.createLiteralTypeNode(ts.factory.createNull()),\n                ]);\n            } else {\n                return type;\n            }\n        };\n\n        switch (javaType) {\n            case 'byte[]':\n            case 'java.lang.Byte[]':\n                return createType(ts.factory.createTypeReferenceNode('Buffer'));\n        }\n\n        if (javaType.endsWith('[]')) {\n            return createType(\n                ts.factory.createArrayTypeNode(\n                    this.javaTypeToTypescriptType(\n                        javaType.substring(0, javaType.length - 2),\n                        isParam\n                    )\n                )\n            );\n        }\n\n        const createTypeReferenceNode = (\n            name: string\n        ): ts.TypeReferenceNode => {\n            if (!this.resolvedImports.includes(name)) {\n                this.additionalImports.push(name);\n            }\n\n            this.importsToResolve.push(name);\n            const isSelf = name === this.classname && isParam;\n            return ts.factory.createTypeReferenceNode(\n                name === this.classname\n                    ? name.substring(name.lastIndexOf('.') + 1) +\n                          (isSelf ? 'Class' : '')\n                    : name.replaceAll('.', '_')\n            );\n        };\n\n        const createUnion = (\n            type: ts.KeywordTypeSyntaxKind,\n            ...additionalTypes: ts.KeywordTypeSyntaxKind[]\n        ): ts.UnionTypeNode => {\n            const types: ts.TypeNode[] = [\n                ts.factory.createKeywordTypeNode(type),\n            ];\n\n            if (!this.isPrimitive(javaType) && strictNullTypes) {\n                types.push(\n                    ts.factory.createLiteralTypeNode(ts.factory.createNull())\n                );\n            }\n\n            if (!isParam) {\n                return ts.factory.createUnionTypeNode(types);\n            }\n\n            return ts.factory.createUnionTypeNode([\n                createTypeReferenceNode(this.primitiveToClassType(javaType)),\n                ...additionalTypes.map((t) =>\n                    ts.factory.createKeywordTypeNode(t)\n                ),\n                ...types,\n            ]);\n        };\n\n        switch (javaType) {\n            case 'int':\n            case 'java.lang.Integer':\n            case 'float':\n            case 'java.lang.Float':\n            case 'double':\n            case 'java.lang.Double':\n            case 'byte':\n            case 'java.lang.Byte':\n            case 'short':\n            case 'java.lang.Short':\n                return createUnion(SyntaxKind.NumberKeyword);\n            case 'long':\n            case 'java.lang.Long':\n                return createUnion(\n                    SyntaxKind.NumberKeyword,\n                    SyntaxKind.BigIntKeyword\n                );\n            case 'char':\n            case 'java.lang.Character':\n            case 'java.lang.String':\n                return createType(\n                    ts.factory.createKeywordTypeNode(SyntaxKind.StringKeyword)\n                );\n            case 'boolean':\n            case 'java.lang.Boolean':\n                return createUnion(SyntaxKind.BooleanKeyword);\n            case 'void':\n            case 'java.lang.Void':\n                return ts.factory.createKeywordTypeNode(SyntaxKind.VoidKeyword);\n            case 'java.lang.Object':\n                this.usesBasicOrJavaType = true;\n                return createType(\n                    ts.factory.createTypeReferenceNode('BasicOrJavaType')\n                );\n            default:\n                return createType(createTypeReferenceNode(javaType));\n        }\n    }\n\n    private convertParameter(\n        param: string,\n        index: number\n    ): ts.ParameterDeclaration {\n        const name = 'var' + index;\n        const type = this.javaTypeToTypescriptType(param, true);\n        return ts.factory.createParameterDeclaration(\n            undefined,\n            undefined,\n            name,\n            undefined,\n            type\n        );\n    }\n\n    private convertParameters(params: MethodDeclaration) {\n        return params.parameters.map(this.convertParameter.bind(this));\n    }\n\n    private static createMethodComment(declaration: MethodDeclaration) {\n        return (\n            '*\\n' +\n            declaration.parameters\n                .map((p, i) => ` * @param var${i} original type: '${p}'\\n`)\n                .join('') +\n            ` * @return original return type: '${declaration.returnType}'\\n `\n        );\n    }\n\n    private createMethod(\n        m: MethodDeclaration,\n        name: string,\n        i: number,\n        isSync: boolean,\n        nonNullReturnType: boolean\n    ): ts.MethodDeclaration {\n        const publicMod = ts.factory.createModifier(\n            ts.SyntaxKind.PublicKeyword\n        );\n        const staticMod = ts.factory.createModifier(\n            ts.SyntaxKind.StaticKeyword\n        );\n\n        const modifiers: ts.Modifier[] = [publicMod];\n        if (m.isStatic) {\n            modifiers.push(staticMod);\n        }\n\n        let returnType = this.javaTypeToTypescriptType(\n            m.returnType,\n            false,\n            !nonNullReturnType\n        );\n        if (!isSync) {\n            returnType = ts.factory.createTypeReferenceNode(\n                ts.factory.createIdentifier('Promise'),\n                [returnType]\n            );\n        }\n\n        let declaration = ts.factory.createMethodDeclaration(\n            modifiers,\n            undefined,\n            name + (isSync ? 'Sync' : ''),\n            undefined,\n            undefined,\n            this.convertParameters(m),\n            returnType,\n            undefined\n        );\n\n        if (i === 0) {\n            declaration = ts.addSyntheticLeadingComment(\n                declaration,\n                ts.SyntaxKind.SingleLineCommentTrivia,\n                ` ================== Method ${name} ==================`,\n                true\n            );\n        }\n\n        return ts.addSyntheticLeadingComment(\n            declaration,\n            ts.SyntaxKind.MultiLineCommentTrivia,\n            TypescriptDefinitionGenerator.createMethodComment(m),\n            true\n        );\n    }\n\n    private convertMethod(\n        method: MethodDeclaration[],\n        name: string\n    ): ts.MethodDeclaration[] {\n        const res: ts.MethodDeclaration[] = [];\n\n        for (let i = 0; i < method.length; i++) {\n            const m = method[i];\n\n            const nonNullReturnType = nonNullReturnMethods.includes(name);\n            res.push(\n                this.createMethod(m, name, i, false, nonNullReturnType),\n                this.createMethod(m, name, i, true, nonNullReturnType)\n            );\n        }\n\n        return res;\n    }\n\n    private getAdditionalImports() {\n        const getPath = (i: string) => {\n            const thisSplit: (string | null)[] = this.classname.split('.');\n            const importSplit: (string | null)[] = i.split('.');\n\n            for (let j = 0; j < thisSplit.length; j++) {\n                if (importSplit[j] === thisSplit[j]) {\n                    thisSplit[j] = null;\n                    importSplit[j] = null;\n                } else {\n                    break;\n                }\n            }\n\n            return (\n                './' +\n                thisSplit\n                    .filter((e) => !!e)\n                    .map(() => '')\n                    .join('../') +\n                importSplit.filter((e) => !!e).join('/')\n            );\n        };\n\n        const unique = <T>(value: T, index: number, self: T[]) => {\n            return self.indexOf(value) === index;\n        };\n\n        return this.importsToResolve\n            .filter((i) => i != this.classname)\n            .filter(unique)\n            .map((i) =>\n                ts.factory.createImportDeclaration(\n                    undefined,\n                    ts.factory.createImportClause(\n                        false,\n                        undefined,\n                        ts.factory.createNamedImports([\n                            ts.factory.createImportSpecifier(\n                                false,\n                                ts.factory.createIdentifier(\n                                    i.substring(i.lastIndexOf('.') + 1)\n                                ),\n                                ts.factory.createIdentifier(\n                                    i.replaceAll('.', '_')\n                                )\n                            ),\n                        ])\n                    ),\n                    ts.factory.createStringLiteral(getPath(i))\n                )\n            );\n    }\n\n    private getImports(): ts.ImportDeclaration {\n        const importElements = [\n            ts.factory.createImportSpecifier(\n                false,\n                undefined,\n                ts.factory.createIdentifier('importClass')\n            ),\n            ts.factory.createImportSpecifier(\n                false,\n                undefined,\n                ts.factory.createIdentifier('JavaClass')\n            ),\n        ];\n\n        if (this.usesBasicOrJavaType) {\n            importElements.push(\n                ts.factory.createImportSpecifier(\n                    false,\n                    undefined,\n                    ts.factory.createIdentifier('BasicOrJavaType')\n                )\n            );\n        }\n\n        const imports = ts.factory.createNamedImports(importElements);\n        return ts.factory.createImportDeclaration(\n            undefined,\n            ts.factory.createImportClause(false, undefined, imports),\n            ts.factory.createStringLiteral('java-bridge')\n        );\n    }\n\n    private getExportStatement(\n        simpleName: string,\n        isAbstractOrInterface: boolean\n    ) {\n        const statement = ts.factory.createClassDeclaration(\n            [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],\n            simpleName,\n            undefined,\n            [\n                ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [\n                    ts.factory.createExpressionWithTypeArguments(\n                        ts.factory.createIdentifier(\n                            `importClass<typeof ${simpleName}Class>(\"${this.classname}\")`\n                        ),\n                        undefined\n                    ),\n                ]),\n            ],\n            isAbstractOrInterface ? [this.createPrivateConstructor()] : []\n        );\n\n        return [\n            ts.addSyntheticLeadingComment(\n                statement,\n                SyntaxKind.MultiLineCommentTrivia,\n                `*\\n * Class ${this.classname}.\\n *\\n` +\n                    ' * This actually imports the java class for further use.\\n' +\n                    ` * The class ${simpleName}Class only defines types, this is the class you should actually import.\\n` +\n                    ' * Please note that this statement imports the underlying java class at runtime, which may take a while.\\n' +\n                    ' * This was generated by java-bridge.\\n * You should probably not edit this.\\n ',\n                true\n            ),\n            ts.factory.createExportDefault(\n                ts.factory.createIdentifier(simpleName)\n            ),\n        ];\n    }\n\n    private getText(nodes: (ts.Node | null)[]) {\n        return nodes\n            .map(\n                (n) =>\n                    (n &&\n                        ts\n                            .createPrinter({ newLine: ts.NewLineKind.LineFeed })\n                            .printNode(\n                                ts.EmitHint.Unspecified,\n                                n,\n                                sourceFile\n                            )) ||\n                    ''\n            )\n            .join('\\n');\n    }\n\n    /**\n     * Generates the typescript definition for the given class.\n     *\n     * @returns the generated typescript definitions\n     */\n    public async generate(): Promise<ModuleDeclaration[]> {\n        if (this.resolvedImports.includes(this.classname)) {\n            return [];\n        }\n\n        this.resolvedImports.push(this.classname);\n        if (this.progressCallback) {\n            this.progressCallback(this.classname);\n        }\n\n        const Class = await importClassAsync(this.classname);\n        const cls = Class.class as ClassClass;\n\n        const simpleName = this.classname.substring(\n            this.classname.lastIndexOf('.') + 1\n        );\n\n        function onlyUnique<T extends { getNameSync(): string }>(\n            value: T,\n            index: number,\n            self: T[]\n        ): boolean {\n            return (\n                self.findIndex(\n                    (el) => value.getNameSync() === el.getNameSync()\n                ) === index\n            );\n        }\n\n        const fields = (await cls.getFields()).filter(onlyUnique);\n        const methods = await cls.getMethods();\n\n        const classMembers: ts.ClassElement[] = await this.convertFields(\n            fields\n        );\n\n        const convertedMethods =\n            await TypescriptDefinitionGenerator.convertMethods(methods);\n        for (const [key, method] of Object.entries(convertedMethods)) {\n            classMembers.push(...this.convertMethod(method, key));\n        }\n\n        const isAbstractOrInterface = await this.isAbstractOrInterface(cls);\n        if (!isAbstractOrInterface) {\n            const constructors = await cls.getDeclaredConstructors();\n            const convertedConstructors = await this.convertConstructors(\n                constructors\n            );\n            classMembers.push(...convertedConstructors);\n        }\n\n        let tsClass = ts.factory.createClassDeclaration(\n            [\n                ts.factory.createModifier(ts.SyntaxKind.ExportKeyword),\n                ts.factory.createModifier(ts.SyntaxKind.DeclareKeyword),\n            ],\n            simpleName + 'Class',\n            undefined,\n            [\n                ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [\n                    ts.factory.createExpressionWithTypeArguments(\n                        ts.factory.createIdentifier('JavaClass'),\n                        undefined\n                    ),\n                ]),\n            ],\n            classMembers\n        );\n\n        tsClass = ts.addSyntheticLeadingComment(\n            tsClass,\n            ts.SyntaxKind.MultiLineCommentTrivia,\n            `*\\n * This class just defines types, you should import ${simpleName} instead of this.\\n` +\n                ' * This was generated by java-bridge.\\n * You should probably not edit this.\\n ',\n            true\n        );\n\n        const sourceText = this.getText([\n            this.getImports(),\n            ...this.getAdditionalImports(),\n            null,\n            tsClass,\n            null,\n            ...this.getExportStatement(simpleName, isAbstractOrInterface),\n        ]);\n\n        const res: ModuleDeclaration[] = [];\n        for (const imported of this.additionalImports) {\n            const generator = new TypescriptDefinitionGenerator(\n                imported,\n                this.progressCallback,\n                this.resolvedImports\n            );\n            const generated = await generator.generate();\n            res.push(...generated);\n        }\n\n        res.push({\n            name: this.classname,\n            contents: sourceText,\n        });\n\n        return res;\n    }\n\n    /**\n     * Save the converted classes to the given directory.\n     *\n     * @param declarations the declarations to save\n     * @param sourceDir the directory to save the files to\n     */\n    public static async save(\n        declarations: ModuleDeclaration[],\n        sourceDir: string\n    ): Promise<void> {\n        for (const declaration of declarations) {\n            const p = declaration.name.split('.');\n            p[p.length - 1] = p[p.length - 1] + '.ts';\n\n            const filePath = path.join(sourceDir, ...p);\n            await fs.promises.mkdir(path.dirname(filePath), {\n                recursive: true,\n            });\n            await fs.promises.writeFile(filePath, declaration.contents, {\n                encoding: 'utf8',\n            });\n        }\n    }\n}\n","/**\n * The supported java versions.\n * Your list of supported versions\n * may differ if you use a different\n * version of the jvm shared library.\n */\nexport enum JavaVersion {\n    /** Java version 1.1 */\n    VER_1_1 = '1.1',\n    /** Java version 1.2 */\n    VER_1_2 = '1.2',\n    /** Java version 1.4 */\n    VER_1_4 = '1.4',\n    /** Java version 1.6 */\n    VER_1_6 = '1.6',\n    /** Java version 1.8 */\n    VER_1_8 = '1.8',\n    /** Java version 9 */\n    VER_9 = '9',\n    /** Java version 10 */\n    VER_10 = '10',\n}\n\nObject.freeze(JavaVersion);\n\n/**\n * Any basic javascript type accepted by this library.\n */\nexport declare type BasicType = string | number | boolean | BigInt | null;\n\n/**\n * Any java type accepted by this library, except arrays.\n */\nexport type BasicOrJavaType =\n    | BasicType\n    | JavaObject\n    | JavaClass\n    | JavaClassType;\n\n/**\n * All types accepted by java\n */\nexport type JavaType = BasicOrJavaType | BasicOrJavaType[];\n\n/**\n * A dummy java object class\n */\nexport abstract class JavaObject {}\n\n/**\n * A java class proxy class.\n * This only exists for temporarily storing\n * the class name and the java instance\n * to create the actual class from using the\n * {@link JavaClassProxy.getClassConstructor()}\n * function.\n */\nexport declare class JavaClassProxy {\n    /**\n     * The class name\n     */\n    public 'class.name': string;\n\n    /**\n     * Get the class's constructor\n     *\n     * @return the java instance proxy constructor\n     */\n    public getClassConstructor<\n        T extends JavaClassType = UnknownJavaClassType\n    >(): T;\n}\n\nexport type JavaClassType = typeof JavaClass;\nexport type UnknownJavaClassType = typeof UnknownJavaClass;\nexport type JavaClassConstructorType = typeof JavaClassConstructor;\n\n/**\n * @inheritDoc UnknownJavaClass\n */\nexport declare class JavaClassInstance extends UnknownJavaClass {}\n\n/**\n * A java class constructor class\n *\n * @see JavaClass\n */\nexport declare class JavaClassConstructor extends JavaClass {\n    public constructor(...args: BasicOrJavaType[]);\n}\n\n/**\n * A constructor type.\n */\nexport type Constructor<T> = { new (): T };\n\n/**\n * A class to be extended for custom class definitions.\n * This does not allow for any methods to be called if not\n * defined in the class definition.\n *\n * ## Example\n * ```ts\n * import { importClass } from 'java-bridge';\n *\n * declare class PersonClass extends JavaClass {\n *     public constructor(name: string, age: number);\n *     public newInstanceAsync(name: string, age: number): Promise<Person>;\n *\n *     public getName(): Promise<string>;\n *     public getNameSync(): string;\n *     public getAge(): Promise<number>;\n *     public getAgeSync(): number;\n * }\n *\n * class Person extends importClass<typeof PersonClass>('com.test.Person') {}\n *\n * const person = new Person('John', 20);\n * console.log(person.getNameSync()); // John\n * console.log(person.getAgeSync()); // 20\n * ```\n */\nexport declare class JavaClass extends JavaObject {\n    /**\n     * Get the java class instance\n     */\n    public static get class(): UnknownJavaClass;\n\n    /**\n     * The class proxy class instance\n     */\n    public static readonly 'class.proxy': JavaClassProxy;\n\n    /**\n     * Check if this is an instance of another class.\n     * Pass either the name of the other class or the class itself\n     * to check if this is an instance of it.\n     * Does not overwrite any existing instanceof operator.\n     * This uses the native java instanceof operator.\n     *\n     * ## Example\n     * ```ts\n     * import { importClass } from 'java-bridge';\n     *\n     * const JavaString = importClass('java.lang.String');\n     * const str = new JavaString('Hello World');\n     *\n     * str.instanceOf(JavaString); // true\n     * str.instanceOf('java.lang.String'); // true\n     * str.instanceOf('java.lang.Object'); // true\n     * str.instanceOf('java.lang.Integer'); // false\n     * ```\n     *\n     * @param other the class to check if this is an instance of\n     * @return true if this is instance of `other`\n     */\n    public instanceOf<T extends object>(other: string | T): boolean;\n\n    /**\n     * Default java equals implementation.\n     * Async call.\n     *\n     * @param o the object to compare this to\n     * @returns true if this matches o\n     */\n    public equals(o: JavaClass): Promise<boolean>;\n\n    /**\n     * Default java equals implementation.\n     * Sync call.\n     *\n     * @param o the object to compare this to\n     * @returns true if this matches o\n     */\n    public equalsSync(o: JavaClass): boolean;\n\n    /**\n     * Java default toString method.\n     * Async call.\n     *\n     * @returns this as a string\n     */\n    public toString(): Promise<string>;\n\n    /**\n     * Java default toString method.\n     * Sync call.\n     *\n     * @returns this as a string\n     */\n    public toStringSync(): string;\n}\n\n/**\n * The java instance proxy class.\n * This class actually does all the magic.\n * After it is created, this will just be a constructor\n * with all static methods and properties (the accessible ones)\n * stored in it and ready for use. Once the actual instance\n * using the new operator is created, a new\n * java_instance_proxy instance is created, containing\n * the actual java instance (that thing isn't visible though)\n * and all (visible) non-static class member methods and properties.\n */\nexport declare class UnknownJavaClass extends JavaClass {\n    /**\n     * Create a new java class instance.\n     * Async version.\n     *\n     * @template T the type of this class as a new instance of this class will be returned\n     * @param args the arguments to create the instance\n     * @return the java_instance_proxy instance\n     */\n    public static newInstanceAsync(\n        this: never,\n        ...args: BasicOrJavaType[]\n    ): Promise<unknown>;\n    public static newInstanceAsync<T extends JavaClass>(\n        this: Constructor<T>,\n        ...args: BasicOrJavaType[]\n    ): Promise<T>;\n\n    /**\n     * Create a new java instance of type\n     * java_instance_proxy[\"class.proxy.instance\"]\n     *\n     * @param args the arguments to create the instance\n     */\n    public constructor(...args: BasicOrJavaType[]);\n\n    /**\n     * Any class member imported.\n     * We'll need to use 'any' as any is callable.\n     * The actual type would be JavaType | ((...args: JavaType[]) => JavaType | Promise<JavaType>).\n     * Just throwing it out there.\n     */\n    [member: string]: any;\n\n    /**\n     * Any static class member imported.\n     * We'll need to use `any` as `any` is callable.\n     * The actual type would be JavaType | ((...args: JavaType[]) => JavaType | Promise<JavaType>)\n     */\n    static [member: string]: any;\n}\n","export {\n    JavaVersion,\n    JavaObject,\n    JavaClassInstance,\n    JavaClassProxy,\n    JavaClass,\n    JavaClassConstructor,\n    UnknownJavaClass,\n    JavaType,\n    BasicOrJavaType,\n    BasicType,\n    JavaClassType,\n    Constructor,\n    UnknownJavaClassType,\n    JavaClassConstructorType,\n} from './definitions';\nimport type * as internal from '../native';\n/**\n * A namespace containing any internal type definitions.\n * Do not actually use anything from this namespace\n * as it only exports types.\n */\nexport type { internal };\nexport * from './java';\nimport * as java from './java';\nexport default java;\nexport { getJavaLibPath } from '../native';\nexport { getJavaVersion, getJavaVersionSync } from './util';\nimport TypescriptDefinitionGenerator from './TypescriptDefinitionGenerator';\nexport { TypescriptDefinitionGenerator };\nexport { TypescriptBulkDefinitionGenerator } from './TypescriptBulkDefinitionGenerator';\nexport {\n    ModuleDeclaration,\n    MethodDeclaration,\n    ProgressCallback,\n} from './TypescriptDefinitionGenerator';\n","import { Java, JavaOptions } from '../native';\nimport {\n    JavaClass,\n    JavaClassConstructorType,\n    JavaVersion,\n    UnknownJavaClass,\n    UnknownJavaClassType,\n} from './definitions';\nimport { getJavaLibPath, getNativeLibPath } from './nativeLib';\n\n/**\n * The static java instance\n */\nlet javaInstance: Java | null = null;\n\n/**\n * Options for creating the Java VM.\n */\nexport interface JVMOptions extends JavaOptions {\n    /***\n     * The path to the native library\n     */\n    libPath?: string | null;\n    /**\n     * The version of the jvm to request\n     */\n    version?: string | JavaVersion | null;\n    /**\n     * Additional arguments to pass to the JVM\n     */\n    opts?: Array<string> | null;\n    /**\n     * Whether this runs inside a packaged electron app\n     */\n    isPackagedElectron?: boolean;\n}\n\n/**\n * Ensure the java vm is created.\n * If the jvm is already created, this does nothing.\n * If the vm is not created yet, the jvm will be created upon this call.\n * This method is also called every time with no arguments when any call\n * to the jvm is done in another method.\n *\n * ## Examples\n * Specify the path to jvm.(dylib|dll|so) manually,\n * specify the java version to use and set to use daemon threads.\n * ```ts\n * import { ensureJvm, JavaVersion } from 'java-bridge';\n *\n * ensureJvm({\n *     libPath: 'path/to/jvm.dll',\n *     version: JavaVersion.VER_9,\n * });\n * ```\n *\n * Let the plugin find the jvm.(dylib|dll|so)\n * ```ts\n * ensureJvm({\n *     version: JavaVersion.VER_9,\n * });\n * ```\n *\n * Let the plugin find the jvm.(dylib|dll|so) and use the default options\n * ```ts\n * ensureJvm();\n * ```\n *\n * ## Notes on the `classpath` option\n *\n * If you need to set the class path *before* jvm startup, for example\n * when using libraries with custom class loaders, you'd need to call\n * `ensureJvm` *before* making any other call to `java-bridge` as those\n * methods may themselves call `ensureJvm` with no arguments\n * (see comment above). Altering the startup classpath after jvm boot is\n * not possible, you can only alter the runtime classpath using\n * `appendClasspath` or `appendClasspathAny` which may not reflect\n * in an altered classpath in your java application/library if your\n * application is using a custom classpath (e.g. Spring Boot).\n *\n * Also, it is not possible to restart the jvm after is has been started\n * once, in order to alter the startup classpath. This is due to some\n * limitations with the destructor feature of the node.js native api,\n * which may not call the destructor in time and having two jvm instances\n * in the same application is not allowed by java. Additionally, destroying\n * the jvm instance may cause *undefined behaviour*, which may or may not\n * cause the application to crash. Let's not do that.\n *\n * @param options the options to use when creating the jvm\n * @return true if the jvm was created and false if the jvm already existed and was not created\n */\nexport function ensureJvm(options?: JVMOptions): boolean {\n    if (!javaInstance) {\n        javaInstance = new Java(\n            options?.libPath,\n            options?.version,\n            options?.opts,\n            options,\n            getJavaLibPath(options?.isPackagedElectron ?? false),\n            getNativeLibPath(options?.isPackagedElectron ?? false)\n        );\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Get the addon's internal class loader.\n * This may be used in combination with {@link setClassLoader}\n * to create a custom class loader and load classes from it.\n *\n * ## Example\n * ```ts\n * import { getClassLoader, setClassLoader, importClass } from 'java-bridge';\n *\n * const classLoader = getClassLoader();\n *\n * const URLClassLoader = importClass('java.net.URLClassLoader');\n * const URL = importClass('java.net.URL');\n *\n * // This actually happens internally when appendClasspath is called\n * const newClassLoader = new URLClassLoader([new URL('file:///path/to/my.jar')], classLoader);\n *\n * setClassLoader(newClassLoader);\n * ```\n */\nexport function getClassLoader(): UnknownJavaClass {\n    ensureJvm();\n    return javaInstance!.classLoader as UnknownJavaClass;\n}\n\n/**\n * Set the internal class loader to use.\n * This allows you to create a custom class loader\n * and import classes using {@link importClass} or {@link importClassAsync}.\n * Without setting the custom class loader, the default class loader will be used.\n *\n * @param classLoader the new class loader to use\n */\nexport function setClassLoader(classLoader: UnknownJavaClass): void {\n    ensureJvm();\n    javaInstance!.classLoader = classLoader;\n}\n\n/**\n * Import a class.\n * Returns the constructor of the class to be created.\n * For example, import \"java.util.ArrayList\" for a java Array List.\n *\n * Define a custom class type for the imported class and pass the\n * constructor type of the class as the template parameter to get\n * the proper type returned. You could also just cast the result.\n *\n * ## Examples\n * ### Import ``java.util.ArrayList`` and create a new instance of it\n * ```ts\n * import { importClass } from 'java-bridge';\n *\n * // Import java.util.ArrayList\n * const ArrayList = importClass('java.util.ArrayList');\n *\n * // Create a new instance of ArrayList\n * const list = new ArrayList();\n * ```\n *\n * ### Import ``java.util.ArrayList`` with types\n * ```ts\n * import { importClass, JavaClassInstance, JavaType } from 'java-bridge';\n *\n * // Definitions for class java.util.List\n * declare class List <T extends JavaType> extends JavaClassInstance {\n *     size(): Promise<number>;\n *     sizeSync(): number;\n *     add(e: T): Promise<void>;\n *     addSync(e: T): void;\n *     get(index: number): Promise<T>;\n *     getSync(index: number): T;\n *     toArray(): Promise<T[]>;\n *     toArraySync(): T[];\n *     isEmpty(): Promise<boolean>;\n *     isEmptySync(): boolean;\n * }\n *\n * // Definitions for class java.util.ArrayList\n * declare class ArrayListClass<T extends JavaType> extends List<T> {\n *     public constructor(other: ArrayListClass<T>);\n *     public constructor();\n * }\n *\n * // This causes the class to be imported when the module is loaded.\n * class ArrayList<T> extends importClass<typeof ArrayListClass>('java.util.ArrayList')<T> {}\n *\n * // Create a new ArrayList instance\n * const list = new ArrayList<string>();\n *\n * // Add some contents to the list\n * list.add('Hello');\n * list.add('World');\n *\n * // Check the list contents\n * assert.equals(list.sizeSync(), 2);\n * assert.equals(list.getSync(0), 'Hello');\n * assert.equals(list.getSync(1), 'World');\n * ```\n *\n * @template T the type of the java class to import as a js type\n * @param classname the name of the class to resolve\n * @return the java class constructor\n */\nexport function importClass<\n    T extends JavaClassConstructorType = UnknownJavaClassType\n>(classname: string): T {\n    ensureJvm();\n    return javaInstance!.importClass(classname) as T;\n}\n\n/**\n * @inheritDoc importClass\n */\nexport function importClassAsync<\n    T extends JavaClassConstructorType = UnknownJavaClassType\n>(classname: string): Promise<T> {\n    ensureJvm();\n    return javaInstance!.importClassAsync(classname) as Promise<T>;\n}\n\n/**\n * Append a single or multiple jars to the class path.\n *\n * Just replaces the old internal class loader with a new one containing the new jars.\n * This doesn't check if the jars are valid and/or even exist.\n * The new classpath will be available to all classes imported after this call.\n *\n * If you want to import whole directories, you can use glob patterns.\n *\n * ## Example\n * ### Append single files\n * ```ts\n * import { appendClasspath } from 'java-bridge';\n *\n * // Append a single jar to the class path\n * appendClasspath('/path/to/jar.jar');\n *\n * // Append multiple jars to the class path\n * appendClasspath(['/path/to/jar1.jar', '/path/to/jar2.jar']);\n * ```\n * or\n * ```ts\n * import { classpath } from 'java-bridge';\n *\n * // Append a single jar to the class path\n * classpath.append('/path/to/jar.jar');\n * ```\n *\n * ### Append a directory to the class path\n * ```ts\n * import { appendClasspath } from 'java-bridge';\n *\n * // Append a directory to the class path\n * appendClasspath('/path/to/dir/*');\n * // Append just the jar files in the directory\n * appendClasspath('/path/to/dir/*.jar');\n * ```\n *\n * @param path the path(s) to add\n */\nexport function appendClasspath(path: string | string[]): void {\n    ensureJvm();\n    javaInstance!.appendClasspath(path);\n}\n\n/**\n * Check if `this_obj` is instance of `other`.\n * This uses the native java `instanceof` operator.\n * You may want to use this if {@link JavaClass.instanceOf}\n * is overridden, as that method itself does not override\n * any method defined in the specific java class named 'instanceOf'.\n *\n * ## Example\n * ```ts\n * import { instanceOf, importClass } from 'java-bridge';\n *\n * const ArrayList = importClass('java.util.ArrayList');\n * const list = new ArrayList();\n *\n * isInstanceOf(list, ArrayList); // true\n * isInstanceOf(list, 'java.util.ArrayList'); // true\n * isInstanceOf(list, 'java.util.List'); // true\n * isInstanceOf(list, 'java.util.Collection'); // true\n * isInstanceOf(list, 'java.lang.Object'); // true\n * isInstanceOf(list, 'java.lang.String'); // false\n *\n * // You can also use the instanceOf method (if not overridden)\n * list.instanceOf(ArrayList); // true\n * list.instanceOf('java.util.ArrayList'); // true\n * list.instanceOf('java.util.List'); // true\n * list.instanceOf('java.util.Collection'); // true\n * list.instanceOf('java.lang.Object'); // true\n * list.instanceOf('java.lang.String'); // false\n * ```\n *\n * @param this_obj the object to check\n * @param other the class or class name to check against\n * @return true if `this_obj` is an instance of `other`\n */\nexport function isInstanceOf<T extends object>(\n    this_obj: JavaClass,\n    other: string | T\n): boolean {\n    ensureJvm();\n    return javaInstance!.isInstanceOf(this_obj, other);\n}\n\n/**\n * Methods for altering and querying the class path.\n * @example\n * import { classpath } from 'java-bridge';\n *\n * // Append a jar to the class path\n * classpath.append('/path/to/jar.jar');\n *\n * assert.equal(classpath.get().length, 1);\n * assert.equal(classpath.get()[0], '/path/to/jar.jar');\n */\nexport namespace classpath {\n    /**\n     * @inheritDoc appendClasspath\n     */\n    export function append(path: string | string[]): void {\n        appendClasspath(path);\n    }\n\n    /**\n     * Get the loaded files or directories in the class path\n     *\n     * @returns a list of the loaded files\n     */\n    export function get(): string[] {\n        ensureJvm();\n        return javaInstance!.loadedJars;\n    }\n}\n\n/**\n * A callback for any output redirected from stdout/stderr from the java process.\n *\n * @param err an error if the conversion of the output failed.\n *            This is null if the output was valid. This will probably never be set.\n * @param data the data that was converted. This is unset if <code>err</code> is set.\n */\nexport type StdoutCallback = (err: Error | null, data?: string) => void;\n\n/**\n * The class guarding the stdout redirect.\n * Keep this instance in scope to not lose the redirect.\n * As soon as this gets garbage collected, the redirection\n * of the stdout/stderr will be stopped. Only one instance\n * of this can exist at a time. Call {@link reset} to stop\n * redirecting the program output and release this class\n * instance early.\n *\n * This can be created by calling {@link stdout.enableRedirect}.\n *\n * ## Example\n * ```ts\n * import { stdout } from 'java-bridge';\n *\n * const guard = stdout.enableRedirect((_, data) => {\n *     console.log('Stdout:', data);\n * }, (_, data) => {\n *     console.error('Stderr:', data);\n * });\n *\n * // Change the receiver method\n * guard.on('stderr', (_, data) => {\n *     console.warn('Stderr:', data);\n * });\n *\n * // Disable a receiver\n * guard.on('stdout', null);\n *\n * // Disable stdout redirect\n * guard.reset();\n * ```\n *\n * ## See also\n * * {@link stdout.enableRedirect}\n */\nexport interface StdoutRedirectGuard {\n    /**\n     * Set the stdout/stderr event handler.\n     * Pass <code>null</code> to disable this specific handler.\n     * Only accepts 'stdout' and 'stderr' as the <code>event</code>\n     * argument. Overwrites the previous handler.\n     *\n     * @param event the event to listen on\n     * @param callback the callback\n     */\n    on(event: 'stdout' | 'stderr', callback: StdoutCallback | null): void;\n\n    /**\n     * Reset this <code>StdoutRedirectGuard</code> instance.\n     * After this call, the stdout/stderr will no longer\n     * be redirected to the specified methods and any call\n     * to this class will throw an error as this counts as destroyed.\n     */\n    reset(): void;\n}\n\n/**\n * A namespace containing methods for redirecting the stdout/stderr of the java process.\n *\n * ## See also\n * * {@link StdoutRedirectGuard}\n * * {@link stdout.enableRedirect}\n */\nexport namespace stdout {\n    /**\n     * Enable stdout/stderr redirection.\n     *\n     * Pass methods for the stdout and stderr output to be redirected to.\n     * These methods must accept an error as the first argument,\n     * although this will probably never be set and can be ignored.\n     * The second argument is the data that was redirected.\n     *\n     * Setting any method to ``null`` or ``undefined`` will disable the redirect for that method.\n     * This also allows you not set any handler which does not make any sense at all.\n     *\n     * ## Examples\n     * ### Redirect all data to the js console\n     * ```ts\n     * import { stdout } from 'java-bridge';\n     *\n     * const guard = stdout.enableRedirect((_, data) => {\n     *     console.log('Stdout:', data);\n     * }, (_, data) => {\n     *     console.error('Stderr:', data);\n     * });\n     * ```\n     *\n     * ### Redirect stdout to the js console\n     * ```ts\n     * const guard = stdout.enableRedirect((_, data) => {\n     *     console.log('Stdout:', data);\n     * });\n     * ```\n     *\n     * ### Redirect stderr to the js console\n     * ```ts\n     * const guard = stdout.enableRedirect(null, (_, data) => {\n     *    console.error('Stderr:', data);\n     * });\n     * ```\n     *\n     * ### Redirect nothing to the js console (y tho)\n     * This enables you to print nothing to nowhere.\n     * ```ts\n     * // Why would you do this?\n     * const guard = stdout.enableRedirect(null, null);\n     *\n     * // Or\n     * const guard = stdout.enableRedirect();\n     * ```\n     *\n     * @see StdoutRedirectGuard\n     * @see StdoutCallback\n     * @param stdout the callback to be called when stdout is received\n     * @param stderr the callback to be called when stderr is received\n     * @returns a <code>StdoutRedirectGuard</code> instance. Keep this instance in scope to not lose the redirect.\n     */\n    export function enableRedirect(\n        stdout?: StdoutCallback | null,\n        stderr?: StdoutCallback | null\n    ): StdoutRedirectGuard {\n        ensureJvm();\n        return javaInstance!.setStdoutCallbacks(stdout, stderr);\n    }\n}\n\n/**\n * The class for implementing java interfaces.\n * Keep this instance in scope to not destroy the java object.\n * Call {@link reset} to instantly destroy this instance.\n *\n * ## Notes\n * Keeping this instance alive may cause your process not to exit\n * early. Thus, you must wait for the javascript garbage collector\n * to destroy this instance even if you called {@link reset}.\n *\n * Once this instance has been destroyed, either by calling {@link reset}\n * or the garbage collector, any call to any method defined earlier\n * by {@link newProxy} will throw an error in the java process.\n *\n * ## Example\n * ```ts\n * import { newProxy } from 'java-bridge';\n *\n * const proxy = newProxy('path.to.MyInterface', {\n *     // Define methods...\n * });\n *\n * // Do something with the proxy\n * instance.someMethod(proxy);\n *\n * // Destroy the proxy\n * proxy.reset();\n * ```\n *\n * ## See also\n * * {@link newProxy}\n */\nexport interface JavaInterfaceProxy {\n    /**\n     * Destroy the proxy class.\n     * After this call any call to any method defined by the\n     * interface will throw an error on the java side. This error\n     * may be thrown back to the node process, if you are not\n     * specifically implementing methods that will be called\n     * from another (java) thread.\n     * Throws an error if the proxy has already been destroyed.\n     */\n    reset(): void;\n}\n\n/**\n * An interface proxy method.\n * Any arguments passed to this method are values converted from java values.\n * The return value will be converted back to a java type.\n *\n * @param args the arguments passed from the java process\n * @return the value to pass back to the java process\n */\nexport type ProxyMethod = (...args: any[]) => any;\ntype InternalProxyRecord = Parameters<\n    typeof Java.prototype.createInterfaceProxy\n>[1];\n\n/**\n * Create a new java interface proxy.\n * This allows you to implement java interfaces in javascript.\n *\n * Pass an object as the second argument with the names of the\n * methods you want to implement as keys and the implementations\n * as values in order to expose these methods to the java process.\n * Any arguments will be converted to javascript values and\n * return values will be converted to java values.\n *\n * When the java process tries to call any method which is\n * not implemented by the proxy, an error will be thrown.\n *\n * ## Examples\n * ### Implement ``java.lang.Runnable``\n * ```ts\n * import { newProxy, importClass } from 'java-bridge';\n *\n * // Define the interface\n * const runnable = newProxy('java.lang.Runnable', {\n *     run: (): void => {\n *         console.log('Hello World!');\n *     }\n * });\n *\n * // Note: You can't do something like this:\n * // runnable.run();\n *\n * // Pass the proxy to a java method instead:\n * const Thread = importClass('java.lang.Thread');\n * const thread = new Thread(runnable); // <- Pass the proxy here\n *\n * // NOTE: You don't have to call this asynchronously\n * // as this call instantly returns.\n * thread.startSync();\n * ```\n *\n * ### Implement ``java.util.function.Function`` to transform a string\n * ```ts\n * const func = newProxy('java.util.function.Function', {\n *     // Any parameters and return types will be automatically converted\n *     apply: (str: string): string => {\n *         return str.toUpperCase();\n *     }\n * });\n *\n * // Import the string class\n * const JString = java.importClass('java.lang.String');\n * const str = new JString('hello');\n *\n * // Pass the proxy.\n * // NOTE: You must call this method async otherwise your program will hang.\n * // See notes for more info.\n * const transformed = await str.transform(func);\n *\n * assert.assertEquals(transformed, 'HELLO');\n * ```\n *\n * Which is equivalent to the following java code:\n * ```java\n * Function<String, String> func = new Function<>() {\n *     @Override\n *     public String apply(String str) {\n *         return str.toUpperCase();\n *     }\n * };\n *\n * String str = \"hello\";\n * String transformed = str.transform(func);\n * assert.assertEquals(transformed, \"HELLO\");\n * ```\n *\n * #### Throwing exceptions\n * Any exceptions thrown by the proxy will be converted to java exceptions\n * and then rethrown in the java process. This may cause the exception\n * to again be rethrown in the javascript process.\n * ```ts\n * const func = newProxy('java.util.function.Function', {\n *     apply: (str: string): string => {\n *         throw new Error('Something went wrong');\n *     }\n * });\n *\n * const JString = java.importClass('java.lang.String');\n * const str = new JString('hello');\n *\n * // This will re-throw the above error\n * const transformed: never = await str.transform(func);\n * ```\n *\n * ## Notes\n * * Keep this instance in scope to not destroy the interface proxy.\n * * Call {@link JavaInterfaceProxy.reset} to instantly destroy this instance.\n * * If any method is queried by the java process and not implemented in here,\n *   an exception will be thrown in the java process.\n * * Any errors thrown in the javascript process will be rethrown in the java process.\n * * **When calling a java method that uses an interface defined by this, you must call\n *   that method using the interface asynchronously as Node.js is single threaded and can't\n *   wait for the java method to return while calling the proxy method at the same time.**\n *\n * ## See also\n * * {@link JavaInterfaceProxy}\n *\n * @param interfaceName the name of the java interface to implement\n * @param methods the methods to implement.\n * @returns a proxy class to pass back to the java process\n */\nexport function newProxy(\n    interfaceName: string,\n    methods: Record<string, ProxyMethod>\n): JavaInterfaceProxy {\n    ensureJvm();\n    const proxyMethods: InternalProxyRecord = Object.create(null);\n\n    for (const [name, method] of Object.entries(methods)) {\n        proxyMethods[name] = (\n            err: null | Error,\n            callback: (err: Error | null, data?: any | null) => void,\n            ...args: any[]\n        ): void => {\n            if (err) {\n                throw err;\n            }\n\n            try {\n                const res = method(...args);\n                callback(null, res);\n            } catch (e: any) {\n                if (e instanceof Error) {\n                    callback(e);\n                } else {\n                    callback(new Error(e.toString()));\n                }\n            }\n        };\n    }\n\n    return javaInstance!.createInterfaceProxy(\n        interfaceName,\n        proxyMethods\n    ) as JavaInterfaceProxy;\n}\n\n/**\n * Get the static java instance.\n * This has no real use, all important methods are exported explicitly.\n */\nexport function getJavaInstance(): Java | null {\n    return javaInstance;\n}\n","import path from 'path';\nimport fs, { readFileSync } from 'fs';\nimport glob from 'glob';\n\nconst { platform, arch } = process;\n\nconst APP_ASAR_REGEX = /([\\\\/])app\\.asar([\\\\/])/gim;\nconst APP_ASAR_UNPACKED = '$1app.asar.unpacked$2';\n\nfunction getModule(base: string, isPackagedElectron: boolean): string {\n    const local = path.join(__dirname, base + '.node');\n\n    if (fs.existsSync(local)) {\n        if (isPackagedElectron) {\n            console.warn('Using local native module in packaged Electron app');\n        }\n\n        return local;\n    } else {\n        const module = base.replaceAll('.', '-').replace('java', 'java-bridge');\n\n        let res: string;\n        // @ts-ignore\n        if (__non_webpack_require__ && __non_webpack_require__.resolve) {\n            // @ts-ignore\n            res = __non_webpack_require__.resolve(module);\n        } else {\n            res = require.resolve(module);\n        }\n\n        if (isPackagedElectron)\n            res = res.replace(APP_ASAR_REGEX, APP_ASAR_UNPACKED);\n        return res;\n    }\n}\n\nfunction UnsupportedPlatform(): Error {\n    return new Error(`Unsupported platform: ${platform} ${arch}`);\n}\n\nfunction isMusl() {\n    // For Node 10\n    if (!process.report || typeof process.report.getReport !== 'function') {\n        try {\n            return readFileSync('/usr/bin/ldd', 'utf8').includes('musl');\n        } catch (e) {\n            return true;\n        }\n    } else {\n        const { glibcVersionRuntime } = (process.report.getReport() as any)\n            .header;\n        return !glibcVersionRuntime;\n    }\n}\n\nexport function getNativeLibPath(isPackagedElectron: boolean): string {\n    switch (platform) {\n        case 'android':\n            switch (arch) {\n                case 'arm64':\n                    return getModule('java.android-arm64', isPackagedElectron);\n                case 'arm':\n                    return getModule(\n                        'java.android-arm-eabi',\n                        isPackagedElectron\n                    );\n                default:\n                    throw UnsupportedPlatform();\n            }\n        case 'win32':\n            return getModule(`java.win32-${arch}-msvc`, isPackagedElectron);\n        case 'darwin':\n            return getModule(`java.darwin-${arch}`, isPackagedElectron);\n        case 'freebsd':\n            return getModule(`java.freebsd-${arch}`, isPackagedElectron);\n        case 'linux':\n            switch (arch) {\n                case 'x64':\n                case 'arm64':\n                    return getModule(\n                        `java.linux-${arch}-${isMusl() ? 'musl' : 'gnu'}`,\n                        isPackagedElectron\n                    );\n                case 'arm':\n                    return getModule(\n                        'java.linux-arm-gnueabihf',\n                        isPackagedElectron\n                    );\n                default:\n                    throw UnsupportedPlatform();\n            }\n        default:\n            throw UnsupportedPlatform();\n    }\n}\n\nexport function getJavaLibPath(isPackagedElectron: boolean): string {\n    let dir = path.join(__dirname, '..', 'java-src', 'build', 'libs');\n    if (isPackagedElectron)\n        dir = dir.replace(APP_ASAR_REGEX, APP_ASAR_UNPACKED);\n\n    const files = glob.sync('*.jar', { cwd: dir });\n    if (files.length === 0) {\n        throw new Error(`No java lib found in ${dir}`);\n    } else {\n        return path.join(dir, files[0]);\n    }\n}\n","import yargs from 'yargs';\nimport { performance } from 'perf_hooks';\nimport path from 'path';\nimport java, {\n    ensureJvm,\n    getJavaInstance,\n    TypescriptDefinitionGenerator,\n} from '../.';\nimport { version } from '../../package.json';\nimport type { Ora } from 'ora';\n\ninterface Args {\n    classnames: string[];\n    output: string;\n    classpath?: string | string[];\n}\n\ntype YargsHandler<T> = (args: yargs.ArgumentsCamelCase<T>) => Promise<void>;\n\nconst importOra = (): Promise<typeof import('ora').default> =>\n    eval(\"import('ora').then(ora => ora.default)\");\nconst importChalk = (): Promise<typeof import('chalk').default> =>\n    eval(\"import('chalk').then(chalk => chalk.default)\");\n\nconst builder: yargs.BuilderCallback<{}, Args> = (command) => {\n    command.positional('classnames', {\n        describe: 'The fully qualified class name(s) to convert',\n        type: 'string',\n    });\n\n    command.positional('output', {\n        describe: 'The output file',\n        type: 'string',\n    });\n\n    command.option('classpath', {\n        alias: 'cp',\n        type: 'string',\n        describe: 'The classpath to use',\n    });\n};\n\nconst handler: YargsHandler<Args> = async ({\n    classnames,\n    output,\n    classpath,\n}) => {\n    let spinner: Ora | null = null;\n    try {\n        const startTime = performance.now();\n        ensureJvm();\n\n        if (classpath) {\n            java.classpath.append(classpath);\n        }\n\n        const chalk = await importChalk();\n        const ora = await importOra();\n\n        console.log(\n            `Starting ${chalk.cyanBright('java-bridge')} ${chalk.greenBright(\n                'v' + version\n            )} Java definition generator`\n        );\n\n        const javaInstance = getJavaInstance()!;\n        const loadedJars = java.classpath.get();\n        if (loadedJars.length > 0) {\n            console.log(\n                `Started JVM with version ${chalk.cyanBright(\n                    javaInstance.version\n                )} and classpath '${loadedJars\n                    .map((j) => chalk.cyanBright(j))\n                    .join(';')}'`\n            );\n        }\n\n        console.log(\n            `Converting classes ${classnames\n                .map((c) => chalk.magentaBright(c))\n                .join(\n                    ', '\n                )} to typescript and saving result to ${chalk.cyanBright(\n                path.normalize(output)\n            )}`\n        );\n\n        spinner = ora().start();\n\n        const resolvedImports: string[] = [];\n        let resolvedCounter: number = 0;\n        let numResolved: number = 0;\n\n        let approximateTimeElapsed: number = 0;\n        let lastClassResolved: string = '';\n        const timeElapsedInterval = setInterval(() => {\n            approximateTimeElapsed += 1;\n            setText();\n        }, 1000);\n\n        const setText = () => {\n            spinner!.text = chalk.gray(\n                `Elapsed time: ${chalk.yellow(\n                    approximateTimeElapsed\n                )} seconds ${chalk.white('|')} Converted ${chalk.cyanBright(\n                    resolvedCounter\n                )} classes ${chalk.white(\n                    '|'\n                )} Converting class ${chalk.magentaBright(lastClassResolved)}`\n            );\n        };\n\n        for (const classname of classnames) {\n            const generator = new TypescriptDefinitionGenerator(\n                classname,\n                (name) => {\n                    lastClassResolved = name;\n                    resolvedCounter++;\n                    setText();\n                },\n                resolvedImports\n            );\n            const generated = await generator.generate();\n            numResolved += generated.length;\n\n            spinner!.text = 'saving results';\n            await TypescriptDefinitionGenerator.save(generated, output);\n        }\n\n        clearInterval(timeElapsedInterval);\n        const timeElapsed = ((performance.now() - startTime) / 1000).toFixed(1);\n        spinner!.succeed(\n            `Success - Converted ${chalk.blueBright(\n                numResolved\n            )} classes in ${chalk.blueBright(timeElapsed)} seconds`\n        );\n    } catch (e) {\n        spinner?.fail('Failed to convert classes');\n        console.error(e);\n        process.exit(1);\n    }\n};\n\nyargs\n    .command<Args>('* <output> <classnames..>', false, builder, handler)\n    .parse();\n","import { importClass, importClassAsync } from './java';\n\n/**\n * Get the version of the Java VM in use.\n * Async version.\n *\n * @see getJavaVersionSync\n * @returns the java version string\n */\nexport async function getJavaVersion(): Promise<string> {\n    const system = await importClassAsync('java.lang.System');\n    return await system.getProperty('java.version');\n}\n\n/**\n * Get the version of the Java VM in use.\n * Sync version.\n *\n * This is equal to the following java implementation:\n * ```java\n * public static String getJavaVersion() {\n *     return System.getProperty(\"java.version\");\n * }\n * ```\n *\n * @see getJavaVersion\n * @returns the java version string\n */\nexport function getJavaVersionSync(): string {\n    const system = importClass('java.lang.System');\n    return system.getPropertySync('java.version');\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 955;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"glob\");","module.exports = require(\"typescript\");","module.exports = require(\"yargs\");","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"perf_hooks\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"\";","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(764);\n"],"names":["root","factory","exports","module","define","amd","global","process","dlopen","__dirname","error","Error","existsSync","readFileSync","join","platform","arch","nativeBinding","localFileExisted","loadError","isMusl","report","getReport","glibcVersionRuntime","header","lddPath","toString","trim","includes","e","Java","JavaInterfaceProxy","StdoutRedirect","getJavaLibPath","declarations","resolvedImports","async","classnames","progressCallback","numResolved","classname","generator","this","generated","generate","length","push","output","save","moduleDeclarations","sourceFile","createSourceFile","ScriptTarget","Latest","ScriptKind","TS","nonNullReturnMethods","TypescriptDefinitionGenerator","usesBasicOrJavaType","additionalImports","importsToResolve","static","methods","Modifier","importClassAsync","result","method","modifiers","getModifiers","isPublic","name","getName","returnType","getReturnType","parameterTypes","getParameterTypes","data","getTypeName","parameters","Promise","all","map","p","isStatic","Object","hasOwn","fields","res","field","type","getType","typeName","tsModifiers","createModifier","SyntaxKind","PublicKeyword","StaticKeyword","isFinal","ReadonlyKeyword","declaration","createPropertyDeclaration","undefined","javaTypeToTypescriptType","addSyntheticLeadingComment","SingleLineCommentTrivia","MultiLineCommentTrivia","classType","isInterface","isAbstract","createPrivateConstructor","createConstructorDeclaration","PrivateKeyword","createBlock","createExpressionStatement","createCallExpression","createSuper","constructors","types","constructor","tsConstructors","t","i","params","convertParameter","bind","createMethod","primitiveToClassType","isPrimitive","javaType","isParam","strictNullTypes","createType","createUnionTypeNode","createLiteralTypeNode","createNull","createTypeReferenceNode","endsWith","createArrayTypeNode","substring","isSelf","lastIndexOf","replaceAll","createUnion","additionalTypes","createKeywordTypeNode","NumberKeyword","BigIntKeyword","StringKeyword","BooleanKeyword","VoidKeyword","param","index","createParameterDeclaration","convertParameters","m","isSync","nonNullReturnType","publicMod","staticMod","createIdentifier","createMethodDeclaration","createMethodComment","convertMethod","getAdditionalImports","getPath","thisSplit","split","importSplit","j","filter","value","self","indexOf","createImportDeclaration","createImportClause","createNamedImports","createImportSpecifier","createStringLiteral","getImports","importElements","imports","getExportStatement","simpleName","isAbstractOrInterface","statement","createClassDeclaration","ExportKeyword","createHeritageClause","ExtendsKeyword","createExpressionWithTypeArguments","createExportDefault","getText","nodes","n","createPrinter","newLine","NewLineKind","LineFeed","printNode","EmitHint","Unspecified","cls","class","getFields","findIndex","el","getNameSync","getMethods","classMembers","convertFields","convertedMethods","convertMethods","key","entries","getDeclaredConstructors","convertedConstructors","convertConstructors","tsClass","DeclareKeyword","sourceText","imported","contents","sourceDir","filePath","promises","mkdir","dirname","recursive","writeFile","encoding","JavaVersion","freeze","JavaObject","JavaClassInstance","JavaClassProxy","JavaClass","JavaClassConstructor","UnknownJavaClass","java","get","getJavaVersion","getJavaVersionSync","TypescriptBulkDefinitionGenerator","javaInstance","ensureJvm","options","libPath","version","opts","isPackagedElectron","getNativeLibPath","appendClasspath","path","classpath","classLoader","importClass","this_obj","other","isInstanceOf","append","loadedJars","stdout","enableRedirect","stderr","setStdoutCallbacks","interfaceName","proxyMethods","create","err","callback","args","createInterfaceProxy","APP_ASAR_REGEX","APP_ASAR_UNPACKED","getModule","base","local","console","warn","replace","resolve","UnsupportedPlatform","dir","files","sync","cwd","importOra","eval","importChalk","builder","command","positional","describe","option","alias","handler","spinner","startTime","performance","now","chalk","ora","log","cyanBright","greenBright","getJavaInstance","c","magentaBright","normalize","start","resolvedCounter","approximateTimeElapsed","lastClassResolved","timeElapsedInterval","setInterval","setText","text","gray","yellow","white","clearInterval","timeElapsed","toFixed","succeed","blueBright","fail","exit","parse","system","getProperty","getPropertySync","webpackEmptyContext","req","code","keys","id","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","call","o","obj","prop","prototype","hasOwnProperty","nmd","paths","children","__webpack_exports__"],"sourceRoot":""}